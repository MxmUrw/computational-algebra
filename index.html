<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Computational Algebra System in Haskell : Library to calculate Gröbner basis written in Haskell.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/pygments.css">
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      tex2jax: {inlineMath: [["\\(","\\)"]],
                displayMath: [["\\[", "\\]"]]},
      jax: ["input/TeX","output/HTML-CSS"],
      TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "https://konn.github.io/xyjax/extensions/TeX/xypic.js"] }
      });
    </script>
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js">
    </script>
    

    <title>Home - Computational Algebra System in Haskell</title>
  </head>
  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/konn/computational-algebra">View on GitHub</a>

          <h1 id="project_title">Computational Algebra System in Haskell</h1>
          <h2 id="project_tagline">Dependently-typed computational algebra system written in Haskell.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/konn/computational-algebra/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/konn/computational-algebra/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3 id="overview">Overview</h3>
<p>The <code>computational-algebra</code> is the computational algebra system, implemented as a Embedded Domain Specific Language (<em>EDSL</em>) in <a href="https://www.haskell.org">Haskell</a>. This library provides many functionality for computational algebra, especially ideal computation such as Groebner basis calculation.</p>
<p>Thanks to Haskell’s powerful language features, this library achieves the following goals:</p>
<dl>
<dt>Type-Safety</dt>
<dd>Haskell’s static type system enforces <strong>static correctness</strong> and prevents you from violating invariants.
</dd>
<dt>Flexibility</dt>
<dd>With the powerful type-system of Haskell, we can write <strong>highly abstract program</strong> resulted in <strong>easy-to-extend</strong> system.
</dd>
<dt>Efficiency</dt>
<dd>Haskell comes with many <strong>aggressive optimization mechanism</strong> and <strong>parallel computation features</strong>, which enables us to write efficient program.
</dd>
</dl>
<p>This package currently provides the following functionalities:</p>
<ul>
<li>Groebner basis calculation w.r.t. arbitrary monomial ordering
<ul>
<li>Currently using Buchberger’s algorithm with some optimization</li>
<li>Faugere’s <span class="math inline">\(F_4\)</span> algorithms is experimentally implemented, but currently not as fast as Buchberger’s algorithm</li>
</ul></li>
<li>Computation in the (multivariate) polynomial ring over arbitarary field and its quotient ring
<ul>
<li>Ideal membership problem</li>
<li>Ideal operations such as intersection, saturation and so on.</li>
<li>Zero-dimensional ideal operation and conversion via FGLM algorithm</li>
<li>Variable elimination</li>
</ul></li>
<li>Find numeric solutions for polynomial system with real coefficient</li>
</ul>
<h3 id="requirements-and-installation">Requirements and Installation</h3>
<p>Old version of this package is <a href="http://hackage.haskell.org/package/computational-algebra">uploaded on Hackage</a>, but it’s rather outdated. Most recent version of <code>computational-algebra</code> is developed on <a href="https://github.com/konn/computational-algebra">GitHub</a>.</p>
<p>It uses the most agressive language features recently implemented in <a href="https://www.haskell.org/ghc/">Glasgow Haskell Compiler</a>, so it requires at least GHC 8.0.1 and also it depends on many packages currently not available on Hackage, but you can install it fairly easily with help of <a href="https://docs.haskellstack.org/en/stable/README/">The Haskell Tool Stack</a>.</p>
<div class="sourceCode"><pre class="sourceCode zsh"><code class="sourceCode zsh">$ curl -sSL https://get.haskellstack.org/ <span class="kw">|</span> <span class="kw">sh</span>
  <span class="co"># if you haven't install Stack yet</span>
$ git <span class="kw">clone</span> https://github.com/konn/computational-algebra
$ <span class="kw">cd</span> computational-algebra
$ stack build</code></pre></div>
<p>In addition, you may need to install GSL and LAPACK (for matrix computation) beforehand. You can install them via Homebrew (OS X), <code>apt-get</code>, or other major package management systems.</p>
<h3 id="example">Example</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ConstraintKinds, DataKinds, GADTs, KindSignatures     #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses, NoImplicitPrelude              #-}</span>
<span class="ot">{-# LANGUAGE NoMonomorphismRestriction, QuasiQuotes, TypeOperators #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Algebra.Algorithms.Groebner</span>
<span class="kw">import </span><span class="dt">Algebra.Field.Finite</span>
<span class="kw">import </span><span class="dt">Algebra.Prelude</span>
<span class="kw">import </span><span class="dt">Data.Type.Ordinal.Builtin</span>

<span class="co">-- | 0-th variable of polynomial ring with at least one variable.</span>
<span class="co">-- Variables are 0-origin.</span>
<span class="ot">x ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">CoeffRing</span> r, <span class="dt">IsMonomialOrder</span> n order, (<span class="dv">0</span> <span class="fu">:&lt;</span> n) <span class="fu">~</span> <span class="ch">'True)</span>
  <span class="ot">=&gt;</span> <span class="dt">OrderedPolynomial</span> r order n
x <span class="fu">=</span> var [od<span class="fu">|</span><span class="dv">0</span><span class="fu">|</span>]

<span class="co">-- | 1-st variable of polynomial ring with at least two variable.</span>
<span class="ot">y ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">CoeffRing</span> r, <span class="dt">IsMonomialOrder</span> n order, (<span class="dv">1</span> <span class="fu">:&lt;</span> n) <span class="fu">~</span> <span class="ch">'True)</span>
  <span class="ot">=&gt;</span> <span class="dt">OrderedPolynomial</span> r order n
y <span class="fu">=</span> var [od<span class="fu">|</span><span class="dv">1</span><span class="fu">|</span>]

<span class="co">-- | The last variable of</span>
<span class="ot">z ::</span> <span class="dt">Polynomial</span> <span class="dt">Rational</span> <span class="dv">3</span>
z <span class="fu">=</span> var [od<span class="fu">|</span><span class="dv">2</span><span class="fu">|</span>]

<span class="co">-- | f in QQ[x,y,z]</span>
<span class="ot">f ::</span> <span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Grevlex</span> <span class="dv">3</span>
f <span class="fu">=</span> <span class="dv">1</span><span class="fu">%</span><span class="dv">2</span><span class="fu">*</span>x<span class="fu">*</span>y<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> y<span class="fu">^</span><span class="dv">2</span>

<span class="co">-- | map f to the F_5[x,y,z], where F_5 = ZZ/5ZZ</span>
<span class="ot">f' ::</span> <span class="dt">Polynomial</span> (<span class="dt">F</span> <span class="dv">5</span>) <span class="dv">3</span>
f' <span class="fu">=</span> mapCoeff (\r <span class="ot">-&gt;</span> fromInteger (numerator r) <span class="fu">/</span> fromInteger (denominator r) ) f

<span class="co">-- | ideal of QQ[x,y,a,b,c,s]</span>
<span class="ot">heron ::</span> <span class="dt">Ideal</span> (<span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Lex</span> <span class="dv">6</span>)
heron <span class="fu">=</span> toIdeal [ <span class="dv">2</span> <span class="fu">*</span> s <span class="fu">-</span> a <span class="fu">*</span> y
                , b<span class="fu">^</span><span class="dv">2</span> <span class="fu">-</span> (x<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> y<span class="fu">^</span><span class="dv">2</span>)
                , c<span class="fu">^</span><span class="dv">2</span> <span class="fu">-</span> ((a <span class="fu">-</span> x)<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> y<span class="fu">^</span><span class="dv">2</span>)
                ]
  <span class="kw">where</span>
    <span class="co">-- | Get the last four variables of QQ[x,y,a,b,c,s]</span>
    [_, _, a, b, c, s] <span class="fu">=</span> vars

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print f
  print f'
  print <span class="fu">$</span> x <span class="fu">*</span> f'<span class="fu">^</span><span class="dv">2</span>
  print <span class="fu">$</span> calcGroebnerBasis heron
  <span class="co">-- print $ f' * 5 + f -- ^ Type error!</span></code></pre></div>
<h3 id="type-interface">Type Interface</h3>
<p><code>computational-algebra</code> provides well-typed interface. In this section, we will see how this package represents mathematical objects by type.</p>
<h4 id="type-level-natural-numbers-and-singletons">Type-level natural numbers and singletons</h4>
<p>As we will see below, we use type-level natural number to indicate the number of variables. So, let’s see how we express natural numbers as type.</p>
<p>The <a href="http://hackage.haskell.org/package/type-natural"><code>type-natural</code> package</a> provides the functionality to treat type-level natural numbers seamlesly. That library also provides Peano numerals, but it is enough to use <code>*.Builtin</code> module for our purposes.</p>
<p>Sometimes we have to specify the type-level natural as function argument explicitly. We use so-called <strong>singleton</strong>s for the type natural in such case. To generate singletons for type-level naturals, we can use <code class="sourceCode haskell">snat</code> quasiquoter from <code class="sourceCode haskell"><span class="dt">Data.Type.Natural.Builtin</span></code> in <code>type-natural</code> package. Furthermore, the <a href="http://hackage.haskell.org/package/singletons"><code>singletons</code> package</a> provides unified way to do with singletons. For more detail, please read the <a href="http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf">original paper of singletons</a>.</p>
<p>For technical reason, the compiler must know the information of specific type-level natural number. This constraint is expressed as the type-class<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat"><code class="sourceCode haskell"><span class="dt">KnownNat</span> n</code></a> from <code class="sourceCode haskell"><span class="dt">GHC.TypeLits</span></code> module, where <span class="math inline">\(n\)</span> is type-level natural. It seems rather noisy to have these constraints all around, but if we have singleton value <code class="sourceCode haskell"><span class="ot">sn ::</span> <span class="dt">SNat</span> n</code> for some <code class="sourceCode haskell">n</code>, then we can give such information to the compiler by <a href="http://hackage.haskell.org/package/singletons/docs/Data-Singletons-TypeLits.html#v:withKnownNat"><code class="sourceCode haskell">withKnownNat</code></a> from <a href="http://hackage.haskell.org/package/singletons/docs/Data-Singletons-TypeLits.html"><code class="sourceCode haskell"><span class="dt">Data.Singletons.TypeLits</span></code></a> of <code>singletons</code> package:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Singletons.TypeLits</span>

<span class="ot">func ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="fu">...</span>

<span class="ot">caller ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="fu">...</span>
caller sn <span class="fu">=</span> withKnownNat n <span class="fu">$</span> func <span class="fu">...</span></code></pre></div>
<h4 id="algebraic-structures-and-operations">Algebraic structures and operations</h4>
<p>To express algebraic structures, we use the type classes from <a href="http://hackage.haskell.org/package/algebra"><code>algebra</code></a> package. For example, if we say “k is a <em>field</em>”, it means that <code class="sourceCode haskell">k</code> is an instance of <code class="sourceCode haskell"><span class="dt">Field</span></code> class from <code>algebra</code> package. As mentioned above, we can compute the Groebner basis for ideals in polynomial rings over arbitary field. This means we can compute bases for those with coefficient field an instance of <code>Field</code>.</p>
<p>The ring and field operations for objects implemented in this package is provided as the instance function of <code class="sourceCode haskell"><span class="dt">Ring</span></code> and <code class="sourceCode haskell"><span class="dt">Field</span></code> classes. Of course, this package also provides instances for the standard type classes such as <code class="sourceCode haskell"><span class="dt">Num</span></code> and <code class="sourceCode haskell"><span class="dt">Fractional</span></code>, but we recommend to use the operation from <code>algebra</code> with <code class="sourceCode haskell"><span class="dt">NoImplicitPrlude</span></code> option. We provide the convenient module <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Prelude.html"><code class="sourceCode haskell"><span class="dt">Algebra.Prelude</span></code></a> to use with <code class="sourceCode haskell"><span class="dt">NoImplicitPrlude</span></code> option.</p>
<h4 id="polynomial">Polynomial</h4>
<p>The type for the polynomials and operations are defined in <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial.html"><code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial</span></code></a> module.</p>
<p><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial.html#t:OrderedPolynomial"><code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span> r ord n</code></a> represents</p>
<ul>
<li>the <span class="math inline">\(n\)</span>-variate polynomial ring,</li>
<li>over the coefficient ring <code class="sourceCode haskell">r</code>,</li>
<li>with terms sorted w.r.t. <a href="http://en.wikipedia.org/wiki/Monomial_order"><em>the monomial ordering</em></a> <code class="sourceCode haskell">ord</code>.</li>
</ul>
<p>In the above, <code class="sourceCode haskell">n</code> should have kind <code class="sourceCode haskell"><span class="dt">Nat</span></code> and <code class="sourceCode haskell">r</code> should be at least an instance of <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#t:CoeffRing"><code class="sourceCode haskell"><span class="dt">CoeffRing</span></code></a>, which is essentially equivalent to “Commutative Ring with decidable equality”, but usually the <a href="docs/algebra-4.3/Numeric-Field-Class.html#t:Field"><code class="sourceCode haskell"><span class="dt">Field</span></code></a> for practical usage. The monomial ordering <code class="sourceCode haskell">ord</code> should be the instance of <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:IsMonomialOrder"><code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code></a>. More precisely, <code class="sourceCode haskell">ord</code> must have instance for <code class="sourceCode haskell"><span class="dt">IsMonomial</span> <span class="dt">Order</span> n ord</code> if and only if <code class="sourceCode haskell">ord</code> stands for some monomial ordering on n-ary polynomial.</p>
<p>Let’s see example. <span class="math inline">\(\mathbb{Q}[x,y,z]\)</span> (the trivariate polynomial ring over the rational number) with Lex ordering is represented by the type <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Lex</span> <span class="dv">3</span></code>. <code class="sourceCode haskell"><span class="dt">Polynomial</span> <span class="dt">Rational</span> <span class="dv">3</span></code> is short for <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Grevlex</span> <span class="dv">3</span></code>.</p>
<h5 id="abstract-type-classes-for-polynomials">Abstract type-classes for Polynomials</h5>
<p>Sometimes, one might want to use different implementation for polynomials optimized to specific task. For such a purpose, we provide two abstract type-classes <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#t:IsPolynomial"><code class="sourceCode haskell"><span class="dt">IsPolynomial</span></code></a> and <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#t:IsOrderedPolynomial"><code class="sourceCode haskell"><span class="dt">IsOrderedPolynomial</span></code></a>, defined in <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html"><code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial.Class</span></code></a> module. Indeed, many algebraic operations for <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span></code> are provided via these classes.</p>
<p>The first <code class="sourceCode haskell"><span class="dt">IsPolynomial</span></code> class abstracts polynomial rings by the universality offree commutative algebra over commutative ring. The instance <code class="sourceCode haskell"><span class="dt">IsPolynomial</span> poly</code> means “<code class="sourceCode haskell">poly</code> is a polynomial ring”. The class comes with two associated types: <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#t:Arity"><code class="sourceCode haskell"><span class="dt">Arity</span></code></a> and <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#t:Coefficient"><code class="sourceCode haskell"><span class="dt">Coefficient</span></code></a>. For example, we have the following instance for <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span></code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">CoeffRing</span> r, <span class="dt">IsMonomialOrder</span> n ord)
      <span class="ot">=&gt;</span> <span class="dt">IsPolynomial</span> (<span class="dt">OrderedPolynomial</span> r ord n) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Arity</span> (<span class="dt">OrderedPolynomial</span> r ord n) <span class="fu">=</span> n
  <span class="kw">type</span> <span class="dt">Coefficient</span> (<span class="dt">OrderedPolynomial</span> r ord n) <span class="fu">=</span> r
  <span class="fu">...</span></code></pre></div>
<p>As their name indicates, <code class="sourceCode haskell"><span class="dt">Arity</span> poly</code> stands for the <em>arity</em> of <code class="sourceCode haskell">poly</code>, that is, the number of variables of <code class="sourceCode haskell">poly</code> and <code class="sourceCode haskell"><span class="dt">Coefficient</span> poly</code> stands for the coefficient ring of <code class="sourceCode haskell">poly</code>. The essential class functions of it is <code class="sourceCode haskell">[var](doc<span class="fu">:</span><span class="dt">Algebra</span><span class="fu">-</span><span class="dt">Ring</span><span class="fu">-</span><span class="dt">Polynomial</span><span class="fu">-</span>Class.html<span class="fu">#</span>v<span class="fu">:</span>var)</code> and <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#v:liftMap"><code class="sourceCode haskell">liftMap</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsPolynomial</span> poly <span class="kw">where</span>
<span class="ot">  var     ::</span> <span class="dt">Ordinal</span> (<span class="dt">Arity</span> poly) <span class="ot">-&gt;</span> poly
<span class="ot">  liftMap ::</span> (<span class="dt">Module</span> (<span class="dt">Scalar</span> (<span class="dt">Coefficient</span> poly)) alg,
              <span class="dt">Ring</span> alg, <span class="dt">Commutative</span> alg)
          <span class="ot">=&gt;</span> (<span class="dt">Ordinal</span> (<span class="dt">Arity</span> poly) <span class="ot">-&gt;</span> alg) <span class="ot">-&gt;</span> poly <span class="ot">-&gt;</span> alg</code></pre></div>
<p><code class="sourceCode haskell">var n</code> stands for the <span class="math inline">\(n\)</span>-th variable of poly. The type <code class="sourceCode haskell"><span class="dt">Ordinal</span> n</code> is provided in <a href="http://hackage.haskell.org/package/type-natural/docs/Data-Type-Ordinal-Builtin.html"><code class="sourceCode haskell"><span class="dt">Data.Type.Ordinal.Builtin</span></code></a> of <code>type-natural</code> package, and it stands for the natural numbers less than n. So, in the context of polynomial, you can think <code class="sourceCode haskell"><span class="dt">Ordinal</span> n</code> as “variable of <span class="math inline">\(n\)</span>-variate polynomial”. One can construct ordinals safely by the quasiquoter <a href="http://hackage.haskell.org/package/type-natural/docs/Data-Type-Ordinal-Builtin.html#v:od"><code>od</code></a> provided in <code class="sourceCode haskell"><span class="dt">Data.Type.Ordinal.Builtin</span></code>, when we use <code class="sourceCode haskell"><span class="dt">QuasiQutoes</span></code> language extension. For example, <code class="sourceCode haskell">[od<span class="fu">|</span><span class="dv">3</span><span class="fu">|</span>]</code> stands for the third ordinal. <code class="sourceCode haskell">[od<span class="fu">|</span><span class="dv">3</span><span class="fu">|</span>]<span class="ot"> ::</span> <span class="dt">Ordinal</span> <span class="dv">4</span></code> typechecks, but <code class="sourceCode haskell">[od<span class="fu">|</span><span class="dv">3</span><span class="fu">|</span>]<span class="ot"> ::</span> <span class="dt">Ordinal</span> <span class="dv">2</span></code> is rejected in compile-time<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>The latter function <code class="sourceCode haskell">liftMap</code> seems to have odd type, but it is just an <em>algebraic substitution mapping</em>. First, <code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Ordinal</span> n <span class="ot">-&gt;</span> <span class="dt">A</span></code> can be seen as “<span class="math inline">\(A\)</span>-valued assignment for each variable”. Then <code class="sourceCode haskell">liftMap f p</code> extends f onto entire polynomial ring <span class="math inline">\(R[X_1,\ldots,X_n]\)</span>, just substituting each variables in <code class="sourceCode haskell">p</code> using <code class="sourceCode haskell">f</code> and taking products in <span class="math inline">\(A\)</span>. These are what we have calld “the universality of free algebra over commutative rings”, as pictured the following diagram:</p>
<!-- ![Universality of free algebra](images/free-alg-univ.svg )  -->
<p><span class="math display">\[\begin{xy}
\xymatrix @C=10ex @R=15ex {
R[X_1, \ldots, X_n] \ar @{.&gt;}[r]^-{\mathop{\mathtt{liftMap}} f} &amp; A\\
\{X_1, \ldots, X_n\} \ar[u]^{\mathtt{var}} \ar[ur]_{f}
}
\end{xy}\]</span></p>
<p>Although, we can derive other algebraic operations from these two functions in theory, but for the practical purpose, <code class="sourceCode haskell"><span class="dt">IsPolynomial</span></code> class have other algebraic operations as its member functions, which can be overridden by instance-specific optimized implementation.</p>
<h5 id="polynomials-and-monomial-orderings">Polynomials and Monomial Orderings</h5>
<p><code class="sourceCode haskell"><span class="dt">IsPolynomial</span></code> class doesn’t incorporate any information on monomial orderings. Polynomial rings with operations related monomial orderings is abstracted in <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#t:IsOrderedPolynomial"><code class="sourceCode haskell"><span class="dt">IsOrderedPolynomial</span></code></a>. This class comes with associated type <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#t:MOrder"><code class="sourceCode haskell"><span class="dt">MOrder</span></code></a>, which stands for the monomial ordering of given polynomial type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="fu">...</span>) <span class="ot">=&gt;</span> <span class="dt">IsOrderedPolynomial</span> (<span class="dt">OrderedPolynomial</span> r ord n) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">MOrder</span> (<span class="dt">OrderedPolynomial</span> r ord n) <span class="fu">=</span> ord
  <span class="fu">...</span></code></pre></div>
<p>This class provide the interfaces to retrieve information related to monomial orderings, such as <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#v:leadingTerm"><code class="sourceCode haskell">leadingTerm</code></a>, <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#v:leadingMonomial"><code class="sourceCode haskell">leadingMonomial</code></a> and <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#v:leadingCoeff"><code class="sourceCode haskell">leadingCoeff</code></a>.</p>
<p>By default, <code>computational-algebra</code> provides the following monomial orderings:</p>
<ul>
<li><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:Lex"><code class="sourceCode haskell"><span class="dt">Lex</span></code></a>, the lexicographical order,</li>
<li><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:Grlex"><code class="sourceCode haskell"><span class="dt">Grlex</span></code></a>, the graded lex order, and</li>
<li><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:Grevlex"><code class="sourceCode haskell"><span class="dt">Grevlex</span></code></a>, the graded reversed lex order.</li>
</ul>
<p>In addition to the basic monomial orders listed above, we can construct new monomial orderings from existing ones with following:</p>
<ul>
<li><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:Graded"><code class="sourceCode haskell"><span class="dt">Graded</span> ord</code></a>, the graded order which first compares the grade (i.e. total degree) and break the tie with <code class="sourceCode haskell">ord</code>,</li>
<li><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:ProductOrder"><code class="sourceCode haskell"><span class="dt">ProductOrder</span> n m ord ord'</code></a>, the product order which compares first n variables with <code class="sourceCode haskell">ord</code>, then the rest <span class="math inline">\(m\)</span> variables with <code class="sourceCode haskell">ord'</code>, and</li>
<li><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:WeightOrder"><code class="sourceCode haskell"><span class="dt">WeightOrder</span> ws ord</code></a>, weighted order which compares the dot-product with ws first and then break the tie with <code class="sourceCode haskell">ord</code>.</li>
</ul>
<p>We provide the <code class="sourceCode haskell"><span class="dt">Revlex</span></code>, the reversed lex order. <code class="sourceCode haskell"><span class="dt">Revlex</span></code> is <strong>not</strong> the monomial order, but we can construct monomial orderings from it with above constructors. For example, <code class="sourceCode haskell"><span class="dt">Graded</span> <span class="dt">Revlex</span></code> is equivalent to <code class="sourceCode haskell"><span class="dt">Grevlex</span></code>.</p>
<p>Other utility functions and related type-classes are defined in the module <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html"><code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial.Monomial</span></code></a>.</p>
<h5 id="how-to-write-ismonomialorder-instances">How to write <code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code> instances?</h5>
<p>If you should use the monomial ordering which cannot constructed from the above, and you have proven that ordering is really a monomial ordering, you can just implement an instance for the <code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code>.</p>
<p>In <code class="sourceCode haskell">computational<span class="fu">-</span>algebra</code>, monomials are essentially represented as <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Internal.html#t:Sized"><code class="sourceCode haskell"><span class="dt">Sized</span> n <span class="dt">Int</span></code></a>, the <code class="sourceCode haskell"><span class="dt">Int</span></code> vector of size <span class="math inline">\(n\)</span> and each <span class="math inline">\(k\)</span>-th element stands for the power of <span class="math inline">\(k\)</span>-th variable.</p>
<p>More precisely, there are two types representing monomials: <code class="sourceCode haskell"><span class="dt">Monomial</span></code> and <code class="sourceCode haskell"><span class="dt">OrderedMonomial</span></code>. The type <code class="sourceCode haskell"><span class="dt">Monomial</span> n</code> is just a synonym of <code class="sourceCode haskell"><span class="dt">Sized</span> n <span class="dt">Int</span></code>, which is mathematically equal to <span class="math inline">\(\mathbb{N}^n\)</span>. You can manipulate the value of <code class="sourceCode haskell"><span class="dt">Monomial</span> n</code> with functions provided by <a href="docs/sized-0.2.0.0/Data-Sized-Builtin.html"><code class="sourceCode haskell"><span class="dt">Data.Sized.Builtin</span></code></a> from <a href="http://hackage.haskell.org/package/sized"><code>sized</code> package</a>.</p>
<p><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:OrderedMonomial"><code class="sourceCode haskell"><span class="dt">OrderedMonomial</span></code></a> is just a newtype wrapping <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:Monomial"><code class="sourceCode haskell"><span class="dt">Monomial</span></code></a> tagged with additional monomial ordering information:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">OrderedMonomial</span> ord n <span class="fu">=</span>
        <span class="dt">OrderedMonomial</span> {<span class="ot"> getMonomial ::</span> <span class="dt">Monomial</span> n }</code></pre></div>
<p>Note that type parameter <code class="sourceCode haskell">ord</code> doesn’t appear in the right hand side of its definition. Such type-parameters are called <em>phantom type</em>s. The type <code class="sourceCode haskell"><span class="dt">OrderedMonomial</span></code> itself doesn’t incorporate any implementation of monomial ordering, but its phantom type paramter <code class="sourceCode haskell">ord</code> carries such information.</p>
<p>We use <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:IsOrder"><code class="sourceCode haskell"><span class="dt">IsOrder</span></code></a> classs to retrieve ordering infromation from such pahntom types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsOrder</span> n ord <span class="kw">where</span>
<span class="ot">  cmpMonomial ::</span> <span class="dt">Proxy</span> ord <span class="ot">-&gt;</span> <span class="dt">Monomial</span> n <span class="ot">-&gt;</span> <span class="dt">Monomial</span> n <span class="ot">-&gt;</span> <span class="dt">Ordering</span></code></pre></div>
<p>That is, <code class="sourceCode haskell"><span class="dt">IsOrder</span> n ord</code> stands for the “<code class="sourceCode haskell">ord</code> is ordering on <span class="math inline">\(\mathbb{N}^n\)</span>” and <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#v:cmpMonomial"><code class="sourceCode haskell">cmpMonomial</code></a> is the function to compare two monomials. The first argument <a href="http://hackage.haskell.org/package/base/docs/Data-Proxy.html#t:Proxy"><code class="sourceCode haskell"><span class="dt">Proxy</span> ord</code></a> is just to indicate “which order to use”, otherwise <code>cmpMonomial</code> can be ambiguous. For example, we have following instance for <code class="sourceCode haskell"><span class="dt">Lex</span></code> <a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> <span class="dt">IsOrder</span> n <span class="dt">Lex</span> <span class="kw">where</span>
  cmpMonomial _ <span class="dt">NilL</span>      <span class="dt">NilL</span>      <span class="fu">=</span> <span class="dt">EQ</span>
  cmpMonomial _ (n <span class="fu">:&lt;</span> ns) (m <span class="fu">:&lt;</span> ms)
    <span class="fu">|</span> n <span class="fu">&lt;</span> m     <span class="fu">=</span> <span class="dt">LT</span>
    <span class="fu">|</span> n <span class="fu">&gt;</span> m     <span class="fu">=</span> <span class="dt">GT</span>
    <span class="fu">|</span> otherwise <span class="fu">=</span> cmpMonomial ns ms</code></pre></div>
<p>The type <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Ordering"><code class="sourceCode haskell"><span class="dt">Ordering</span></code></a> is one of the Haskell’s standard data-type which stands for the “comparison result” of two values; that is, <code class="sourceCode haskell">compare n m</code> returns <code class="sourceCode haskell"><span class="dt">LT</span></code> if <span class="math inline">\(n &lt; m\)</span>, <code class="sourceCode haskell"><span class="dt">GT</span></code> if <span class="math inline">\(n &gt; m\)</span> and <code class="sourceCode haskell"><span class="dt">EQ</span></code> if they are equal. Haskell’s <a href="http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Monoid"><code class="sourceCode haskell"><span class="dt">Monoid</span></code></a> type-class and <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html"><code class="sourceCode haskell"><span class="dt">Data.Ord</span></code></a> module provides more convenient way to write such a comparison function. For example, we can rewrite above definition as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">cmpMonomial _ ns ms <span class="fu">=</span> mconcat (zipWithSame compare ns ms)</code></pre></div>
<p>where <a href="docs/sized-0.2.0.0/Data-Sized.html#v:zipWithSame"><code class="sourceCode haskell">zipWithSame</code></a> is imported from <code class="sourceCode haskell"><span class="dt">Data.Sized.Builtin</span></code> from <code>sized</code> package. Monoid opertions for <code class="sourceCode haskell"><span class="dt">Ordering</span></code> can be considered as left-biased “breaking tie” operator.</p>
<p>The <code class="sourceCode haskell"><span class="dt">Ord</span></code> instance for <code class="sourceCode haskell"><span class="dt">Monomial</span> ord n</code> is defined if <code class="sourceCode haskell"><span class="dt">IsOrder</span> n ord</code> is defined. But the above definition only requires <code>ord</code> to be “total order”; it should be monomial ordering to treat do polynomials. So, if one have proven that some <code>ord</code> is actually a monomial order, one should declare the instance for <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:IsMonomialOrder"><code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code></a> as below:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">IsMonomialOrder</span> n <span class="dt">Lex</span></code></pre></div>
<p><code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code> doesn’t provide any additional member function, but it is defined to distinguish mere ordering with monomial ordering. It is instance-implementor’s responsibility to assure that it is really a monomial ordering<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p>So in this way, we can define the custom monomial ordering.</p>
<p>There is yet another type-class for monomial orderings: <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#t:IsStrongMonomialOrder"><strong><code class="sourceCode haskell"><span class="dt">IsStrongMonomialOrder</span></code></strong></a>. <code class="sourceCode haskell"><span class="dt">IsOrder</span></code> and <code class="sourceCode haskell"><span class="dt">IsMonomialOrder</span></code> takes fixed arity as its parameter, but sometimes we require orderings to work with arbitarary many variables. If some specific oreder <code>ord</code> has <code>IsMonomialOrder n ord</code> for each <span class="math inline">\(n\)</span>, then GHC automatically generates the instance <code class="sourceCode haskell"><span class="dt">IsStrongMonomialOrder</span> ord</code>. One can use <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Monomial.html#v:cmpAnyMonomial"><code>cmpAnyMonomial</code></a> function to compare monomials with different arity for such an ordering.</p>
<h4 id="variants-of-polynomial-types">Variants of polynomial types</h4>
<p>There are several polynomial types shipped with this library other than <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span></code>:</p>
<ul>
<li><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Univariate.html#t:Unipol"><code class="sourceCode haskell"><span class="dt">Unipol</span> r</code></a> defined in <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Univariate.html"><code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial.Univariate</span></code></a>, which stands for univariate polynomial <span class="math inline">\(R[x]\)</span> over some commutative ring <span class="math inline">\(R\)</span>. It comes with operations optimized to univariate polynomials, such as efficient substitution using <a href="https://en.wikipedia.org/wiki/Horner%27s_method">Horner’s rule</a> and fast multplication using <a href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba algorithm</a>.</li>
<li><p><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Labeled.html#t:LabPolynomial"><code class="sourceCode haskell"><span class="dt">LabPolynomial</span> poly vars</code></a> defined in <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Labeled.html"><code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial.Labeled</span></code></a>. It wraps existing polynomial type <code class="sourceCode haskell">poly</code> and have the same operation with it, but it <em>labels</em> each variables in <code class="sourceCode haskell">poly</code> by <code class="sourceCode haskell">vars</code>. Parameter <code class="sourceCode haskell">vars</code> is the type-level list of unique symbols which have the length equal to the arity of <code class="sourceCode haskell">poly</code> and. For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">LabPolynomial</span> (<span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Grevlex</span> <span class="dv">3</span>) <span class="ch">'[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span></code></pre></div>
<p>is essentially the same as <code class="sourceCode haskell"><span class="dt">OrderedPolynomial</span> <span class="dt">Rational</span> <span class="dt">Grevlex</span> <span class="dv">3</span></code> , but each variable is “labeled” with names <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span> when we prrety-print values. It also provides strongly-typed inclusion mapping. For exmap,e. compiler can statically generate inclusion mapping from <code class="sourceCode haskell"><span class="dt">LabPolynomial</span> poly <span class="ch">'[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span></code> to <code class="sourceCode haskell"><span class="dt">LabPolynomial</span> poly <span class="ch">'[&quot;z&quot;, &quot;a&quot;, &quot;x&quot;, &quot;b&quot;, &quot;c&quot;]</span></code> .</p></li>
</ul>
<p>Of course, users can define their custom polynomial types and made them instance of <code class="sourceCode haskell"><span class="dt">IsOrdredPolynomial</span></code>. The module <code class="sourceCode haskell"><span class="dt">Algebra.Ring.Polynomial.Class</span></code> provides the function <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#v:injectVars"><code class="sourceCode haskell">injectVars</code></a>, which converts between different polynomial type with the same coefficient, just mapping each variable to corresponding one with the same index in the target. Sometimes (e.g. variable elimination) one might want to permute variables. In such a case, you can just use <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#v:liftMap"><code class="sourceCode haskell">liftMap</code></a>, <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Ring-Polynomial-Class.html#v:subst"><code class="sourceCode haskell">subst</code></a> or their variants.</p>
<h4 id="finite-fields">Finite Fields</h4>
<p><a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Finite.html"><code class="sourceCode haskell"><span class="dt">Algebra.Field.Finite</span></code></a> provides the type-class for finite fields <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Finite.html#t:FiniteField"><code class="sourceCode haskell"><span class="dt">FiniteField</span></code></a> and concrete types for prime field <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Finite.html#t:F"><code class="sourceCode haskell"><span class="dt">F</span> p</code></a> which corresponds to <span class="math inline">\(\mathbb{F}_p = \mathbb{Z}/p\mathbb{Z}\)</span>. Note that, this type doesn’t check primarity of type parameter <span class="math inline">\(p\)</span> (too expensive!).</p>
<p>For other general finite fields other than prime fields (Galois Field), you can use <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html"><code class="sourceCode haskell"><span class="dt">Algebra.Field.Galois</span></code></a> module provides types <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html#t:GF"><code class="sourceCode haskell"><span class="dt">GF</span> p n</code></a>, which corresponds to <span class="math inline">\(\mathbb{F}_{p^n}\)</span>. We use <a href="https://en.wikipedia.org/wiki/Conway_polynomial_(finite_fields)">Conway polynomial</a> for internal representation of Galois Fields. As a default, <code>computational-algebra</code> comes with the information of Conway polynomials for 10th power of 2,3,5,7,11. Users can easily add the information by just defining <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html#t:ConwayPolynomial"><code class="sourceCode haskell"><span class="dt">ConwayPolynomial</span> p n</code></a> instace for specific <span class="math inline">\(p\)</span> an <span class="math inline">\(n\)</span> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConwayPolynomial</span> <span class="dv">19</span> <span class="dv">1</span> <span class="kw">where</span>
  conwayPolynomial _ _ <span class="fu">=</span> x <span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> <span class="dv">18</span> <span class="fu">*</span> x <span class="fu">+</span> <span class="dv">2</span>
    <span class="kw">where</span> x <span class="fu">=</span> var <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Unipol</span> (<span class="dt">F</span> <span class="dv">19</span>)</code></pre></div>
<p>Although we are planning to implement the functionality to automatically calculate Conway Polynomial, it is recomended to provide concrete value for each specific <span class="math inline">\(p\)</span> and <span class="math inline">\(n\)</span> to gain the efficiency. The <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html#v:primitive"><code class="sourceCode haskell"><span class="kw">primitive</span></code></a> constant(s) stands for a primitive element of <span class="math inline">\(\mathbb{F}_{p^n}\)</span>, i.e. a generator of the multiplicative group <span class="math inline">\(\mathbb{F}_{p^n}^\times\)</span> of units.</p>
<h5 id="galois-field-computation-with-arbitrary-irreducible-polynomials">Galois Field computation with arbitrary irreducible polynomials</h5>
<p>Although Conway polynomials provides systematic way to treat field extensions, it takes some computational overhead to compute Conway polynomial. So if one doesn’t need to treat field extension, it is enough to chose arbitrary irreducible polynomial of degree <span class="math inline">\(n\)</span> with coeffcients in <span class="math inline">\(\mathbb{F}_p\)</span> to do computation.</p>
<p>Internally, the type <code class="sourceCode haskell"><span class="dt">GF</span> p n</code> is synonym for <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html#t:GF'"><code class="sourceCode haskell"><span class="dt">GF'</span> p n (<span class="dt">Conway</span> p n)</code></a>; here, <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html#t:Conway"><code class="sourceCode haskell"><span class="dt">Conway</span> p n</code></a> is a placeholder to retrieve the information of conway polynomial for <span class="math inline">\(\mathbb{F}_{p^n}\)</span>. Actual computation algorithm for Galios fields is defined for <code class="sourceCode haskell"><span class="dt">GF'</span> p n f</code> for <code class="sourceCode haskell">f</code> carrying information of such an irreducible polynomial. So if we have some irreducible <span class="math inline">\(p \in \mathbb{F}_p[x]\)</span> with <span class="math inline">\(\deg(p) = n\)</span>, one can compute in <span class="math inline">\(\mathbb{F}_{p^n}\)</span> by <em>reflecting</em> the information of <span class="math inline">\(p\)</span> to parameter <code class="sourceCode haskell">f</code>. The <a href="http://hackage.haskell.org/package/reflection"><code>reflection</code> package</a> provides general way to do such a type-level reflection. Based on that, <code class="sourceCode haskell"><span class="dt">Algebra.Field.Galois</span></code> provides utility function to reflect given irreducible polynomial to type-level: <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html#v:withIrreducible"><code class="sourceCode haskell">withIrreducible</code></a>. Suppose <span class="math inline">\(p \in \mathbb{F}_5\)</span> is irreducible and <span class="math inline">\(\deg(p) = 7\)</span>. Then we can do computation in <span class="math inline">\(\mathbb{F}_{5^7}\)</span> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">withIrreducible p <span class="fu">$</span> \pxy <span class="ot">-&gt;</span>
  show (sqrt (<span class="dv">3</span> <span class="ot">`asProxyTypeOf`</span> pxy))</code></pre></div>
<p>In above, <code class="sourceCode haskell">pxy</code> is Proxy type to carry the information of <em>reflected</em> field and <a href="http://hackage.haskell.org/package/base/docs/Data-Proxy.html#v:asProxyTypeOf"><code class="sourceCode haskell">asProxyTypeOf</code></a> forces literals to be interpreted as an element of the reflected field. One thing to note is that the type variable <code class="sourceCode haskell">f</code> <em>dynamically</em> reflecting polynomial cannot <em>leak</em> outside of given functions. For example, the value <code class="sourceCode haskell"><span class="dt">GF'</span> p n f</code> itself cannot be taken out from <code class="sourceCode haskell">withIrreducible</code> :</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">withIrreducible p <span class="fu">$</span> \pxy <span class="ot">-&gt;</span>
  <span class="kw">primitive</span> <span class="fu">*</span> (<span class="dv">2</span> <span class="fu">*</span> primivite <span class="fu">-</span> <span class="dv">1</span>) <span class="ot">`asProxyTypeOf`</span> pxy <span class="co">-- type error!</span></code></pre></div>
<p>In such a situation, one cannot “take out” the reulst directly, but one can still extract the <em>linear representation</em> of it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">withIrreducible p <span class="fu">$</span> \pxy <span class="ot">-&gt;</span>
  linearRepGF (<span class="kw">primitive</span> <span class="fu">*</span> (<span class="dv">2</span> <span class="fu">*</span> primivite <span class="fu">-</span> <span class="dv">1</span>) <span class="ot">`asProxyTypeOf`</span> pxy) <span class="co">-- OK!</span></code></pre></div>
<p>On the other hand, if we adopt Conway polynomials as a representation, one can do any computation without any scope restriction as this. This is because <code class="sourceCode haskell"><span class="dt">Conway</span> p n</code> carries information of an irreducible polynomial <em>statically</em>. So you can define <a href="http://hackage.haskell.org/package/reflection/docs/Data-Reflection.html#t:Reifies"><code class="sourceCode haskell"><span class="dt">Reifies</span></code></a> instance for your custom placeholder type and store the information of some specific irreducible polynomial, then you can do such a calculation without any scoping problem:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MyPoly</span> <span class="fu">=</span> <span class="dt">MyPoly</span> <span class="co">-- ^ Just for placeholder</span>

<span class="kw">instance</span> <span class="dt">Reifies</span> <span class="dt">MyPoly</span> (<span class="dt">Unipol</span> (<span class="dt">F</span> <span class="dv">5</span>)) <span class="kw">where</span>
  reflect _ <span class="fu">=</span> x<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> <span class="dv">2</span> x <span class="fu">+</span> <span class="dv">4</span>

<span class="kw">type</span> <span class="dt">MyGF5'2</span> <span class="fu">=</span> <span class="dt">GF'</span> <span class="dv">5</span> <span class="dv">2</span> <span class="dt">MyPoly</span>
<span class="fu">...</span></code></pre></div>
<p>Also, <code class="sourceCode haskell"><span class="dt">Algebra.Field.Galois</span></code> comes with monadic function <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html#v:generateIrreducible"><code class="sourceCode haskell">generateIrreducible</code></a> to find irreducible polynomials and <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html#v:reifyGF'"><code class="sourceCode haskell">reifyGF'</code></a> combining these two functions. There is another function <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html#v:withGF'"><code class="sourceCode haskell">withGF'</code></a> to retrieve linear representation of elements of Galois Field. See <a href="https://konn.github.io/computational-algebra/docs/computational-algebra-0.4.0.0/Algebra-Field-Galois.html">documents</a> for more information.</p>
<h4 id="quotient-ring">Quotient ring</h4>
<p>The type <code class="sourceCode haskell"><span class="dt">Quotient</span> k ord n ideal</code> stands for the quotient ring of n-variate polynomial ring over the field <code class="sourceCode haskell">k</code>. In order to distinguish the quotient ring over different ideals, we parametrize ideals in type. We use the functionalities provided by <code class="sourceCode haskell">reflection</code> package here, again.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>One can also construct ordinals using integer literals of Haskell, like <code class="sourceCode haskell"><span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Ordinal</span> <span class="dv">4</span></code>, but it is unsafe and so highly unrecommended. For example, although <code class="sourceCode haskell">[od<span class="fu">|</span><span class="dv">3</span><span class="fu">|</span>]<span class="ot"> ::</span> <span class="dt">Ordinal</span> <span class="dv">2</span></code> is rejected by compiler as expected, but <code class="sourceCode haskell"><span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Ordinal</span> <span class="dv">2</span></code> passes the compile-time typecheck and throws run-time error. This is due to the mechanism of Haskell’s literal desugaring.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Indeed, actual implementation is more optimized.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Actually, recent GHC’s type-level functionality is strong enough to require instances to include static proof of correctness; but it is too expensive for library writers compared to the result we gain, hence we haven’t include such “proof requirement” to class. Another reason is that, it makes difficult to treat <em>dynamically generated orderings</em>, which occurs in some applications such as integer programming.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Computational Algebra System in Haskell maintained by <a href="https://github.com/konn">konn</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
        <p>Proudedly generated by <a href="http://jaspervdj.be/hakyll/">Hakyll</a>
	, <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a> and <a href="https://www.haskell.org">Haskell</a></p>
      </footer>
    </div>
  </body>
</html>

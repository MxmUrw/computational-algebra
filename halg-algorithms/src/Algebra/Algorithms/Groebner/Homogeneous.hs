{-# LANGUAGE DataKinds, DeriveFoldable, DeriveFunctor, MultiWayIf #-}
{-# LANGUAGE OverloadedLabels, ScopedTypeVariables                #-}
module Algebra.Algorithms.Groebner.Homogeneous
       ( calcGroebnerBasisAfterHomogenising
       , calcHomogeneousGroebnerBasis
       , unsafeCalcHomogeneousGroebnerBasis
       , hilbertPoincareSeries
       , hilbertPoincareSeriesBy
       ) where
import           Algebra.Algorithms.Groebner
import           Algebra.Field.RationalFunction
import           Algebra.Prelude.Core                hiding (empty, filter,
                                                      insert)
import           Algebra.Ring.Polynomial.Homogenised
import           Control.Lens                        (ix, (%~), (&))
import           Control.Monad.Loops                 (whileJust_)
import           Control.Monad.ST.Strict
import qualified Data.Coerce                         as C
import qualified Data.Foldable                       as F
import           Data.Function                       (on)
import           Data.Functor.Identity
import           Data.Heap                           (Entry (..), Heap)
import qualified Data.Heap                           as H
import qualified Data.List                           as L
import           Data.Maybe                          (fromJust)
import qualified Data.Sized.Builtin                  as SV
import           Data.STRef                          (STRef, modifySTRef',
                                                      newSTRef, readSTRef,
                                                      writeSTRef)
import qualified Data.Vector                         as V
import qualified Data.Vector.Mutable                 as MV
import           GHC.Exts                            (Constraint)
import qualified Prelude                             as P

isHomogeneous :: IsOrderedPolynomial poly
              => poly -> Bool
isHomogeneous poly =
  let degs = map F.sum $ F.toList $ monomials poly
  in and $ zipWith (==) degs (tail degs)

-- | Calculates Groebner basis once homogenise, apply @'unsafeCalcHomogeneousGroebnerBasis'@,
--   and then dehomogenise.
calcGroebnerBasisAfterHomogenising :: (Field (Coefficient poly), IsOrderedPolynomial poly)
                  => Ideal poly -> [poly]
calcGroebnerBasisAfterHomogenising i
  | F.all isHomogeneous i = unsafeCalcHomogeneousGroebnerBasis i
  | otherwise = map unhomogenise $ unsafeCalcHomogeneousGroebnerBasis $ fmap homogenise i

-- | Calculates a Groebner basis of the given /homogeneous/ ideal,
--   i.e. an ideal generated by homogeneous polynomials.
--   Returns @'Nothing'@ if the given ideal is inhomogeneous.
--
--   See also @'unsafeCalcHomogeneousGroebnerBasis'@.
calcHomogeneousGroebnerBasis :: (Field (Coefficient poly), IsOrderedPolynomial poly)
                             => Ideal poly -> Maybe [poly]
calcHomogeneousGroebnerBasis i
  | F.all isHomogeneous i = Just $ unsafeCalcHomogeneousGroebnerBasis i
  | otherwise = Nothing

-- | Calculates a Groebner basis of the given /homogeneous/ ideal,
--   i.e. an ideal generated by homogeneous polynomials.
--
--   __N.B.__ This function /DOES NOT/ check homogeniety of the given ideal.
--   See also @'calcHomogeneousGroebnerBasis'@.
unsafeCalcHomogeneousGroebnerBasis :: (Field (Coefficient poly), IsOrderedPolynomial poly)
                             => Ideal poly -> [poly]
unsafeCalcHomogeneousGroebnerBasis ideal = runST $ do
  gs <- newSTRef =<< V.unsafeThaw (V.fromList $ generators ideal)
  sigs <- newSTRef
          =<< buildTable gs [0 .. length (generators ideal) - 1]
  let ins g = do
        j <- snoc gs g
        news <- buildTable gs [j]
        modifySTRef' sigs $ H.union news
  whileJust_ (H.uncons <$> readSTRef sigs) $ \(Entry _ (i, j), h') -> do
    writeSTRef sigs h'
    (fi, fj) <- (,) <$> at gs i <*> at gs j
    gs' <- V.toList <$> (V.unsafeFreeze =<< readSTRef gs)
    let s = sPolynomial fi fj `modPolynomial` gs'
    unless (isZero s) $ ins s
  V.toList <$> (V.unsafeFreeze =<< readSTRef gs)

type Signatures weight = H.Heap (Entry weight (Int, Int))

buildTable :: IsOrderedPolynomial poly
           => RefVec s poly -> [Int] -> ST s (Signatures Int)
buildTable gs inds =
  H.fromList <$> sequence
          [ flip Entry (i, j) <$> deg gs i j
          | j <- inds
          , i <- [0 .. j - 1]
          ]

type RefVec s a = STRef s (MV.MVector s a)

at :: RefVec s a -> Int -> ST s a
at mv i = flip MV.read i =<< readSTRef mv

snoc :: RefVec s a -> a -> ST s Int
snoc ref v = do
  vec <- flip MV.grow 1 =<< readSTRef ref
  let ind = MV.length vec - 1
  MV.write vec ind v
  writeSTRef ref vec
  return ind
{-# INLINE snoc #-}

deg :: IsOrderedPolynomial poly => RefVec s poly -> Int -> Int -> ST s Int
deg gs i j = do
  vec <- readSTRef gs
  (totalDegree .) . (lcmMonomial `on` leadingMonomial)
       <$> MV.read vec i
       <*> MV.read vec j
{-# INLINE deg #-}

data ReversedEntry p a = ReversedEntry { rePriority :: p
                                       , rePayload  :: a}
                     deriving (Read, Show, Functor, Foldable)

instance Eq p => Eq (ReversedEntry p a) where
  (==) = (==) `on` rePriority

instance (Ord p) => Ord (ReversedEntry p a) where
  compare = flip (comparing rePriority)

viewMax :: Ord p => Heap (ReversedEntry p a) -> Maybe (ReversedEntry p a, Heap (ReversedEntry p a))
viewMax = H.viewMin

-- | @'hilbertPoincareSeries' k i@ computes a Hilbert-Poincare formal series
--   for given monomial ideal i over a field k.
hilbertPoincareSeriesForMonomials :: forall n. (KnownNat n)
                                  => [Monomial n] -> RationalFunction Rational
hilbertPoincareSeriesForMonomials ms0 =
  go $ H.fromList [ ReversedEntry (F.sum m) m | m <- minimalGenerators ms0 ]
  where
    go ms =
      let n  = fromIntegral $ natVal (Proxy :: Proxy n)
      in case viewMax ms of
        Nothing -> recip ((one - #x) ^ n)
        Just (ReversedEntry 0 _, _) -> 0
        Just (ReversedEntry 1 _, _) -> recip ((one - #x) ^ (n P.- fromIntegral (H.size ms)))
        Just (ReversedEntry _ m, _) ->
          let Just i = SV.sFindIndex (> 0) m
              xi = varMonom sing i
              upd (ReversedEntry d xs) =
                   ReversedEntry (d - 1) (xs & ix i %~ pred)
              added = minimalGenerators' $ insert (ReversedEntry 1 xi) ms
              quo = minimalGenerators' $ H.mapMonotonic upd $
                    filter ((>0) . sIndex i . rePayload) ms
          in go added + #x * go quo

class (Foldable f) => Container f where
  type Element f a :: Constraint
  filter    :: (a -> Bool) -> f a -> f a
  insert    :: Element f a => a -> f a -> f a
  empty     :: f a

instance Container Heap where
  {-# SPECIALISE instance Container Heap #-}
  type Element Heap a = (Ord a)
  filter = H.filter
  insert = H.insert
  empty = H.empty

instance Container [] where
  {-# SPECIALISE instance Container [] #-}
  type Element [] a = ()
  filter = L.filter
  insert = (:)
  empty = []

head' :: Foldable t => t a -> a
head' = fromJust . F.find (const True)

divs' :: Foldable t => t (Monomial n) -> t (Monomial n) -> Bool
divs' = divs `on` orderMonomial (Just Lex) . head'

minimalGenerators' :: forall t f n. (Container t, KnownNat n, Element t (f (Monomial n)), Foldable f)
                  => t (f (Monomial n)) -> t (f (Monomial n))
minimalGenerators' bs
  | any (all (== 0) . head') bs = empty
  | otherwise = F.foldr check empty bs
  where
    check a acc =
      if any (`divs'` a) acc
      then acc
      else insert a $ filter (not . (a `divs'`)) acc
{-# SPECIALISE minimalGenerators' :: KnownNat n => [Identity (Monomial n)] -> [Identity (Monomial n)] #-}
{-# SPECIALISE minimalGenerators' :: (KnownNat n, Ord p) => Heap (ReversedEntry p (Monomial n)) -> Heap (ReversedEntry p (Monomial n)) #-}

-- | Computes a minimal generator of monomial ideal
minimalGenerators :: KnownNat n => [Monomial n] -> [Monomial n]
minimalGenerators =
  C.coerce . minimalGenerators' .
  (C.coerce :: [Monomial n] -> [Identity (Monomial n)])
{-# INLINE minimalGenerators #-}

-- | Calculates the Hilbert-Poincare serires of a given homogeneous ideal,
--   using the specified monomial ordering.
hilbertPoincareSeriesBy :: (IsMonomialOrder (Arity poly) ord, Field (Coefficient poly), IsOrderedPolynomial poly)
                        => ord -> Ideal poly -> RationalFunction Rational
hilbertPoincareSeriesBy ord =
    hilbertPoincareSeriesForMonomials
  . map (getMonomial . leadingMonomial)
  . calcGroebnerBasisWith ord

-- | A variant of @'hilbertPoincareSeriesBy'@ using @'Grevlex'@ ordering.
hilbertPoincareSeries :: (Field (Coefficient poly), IsOrderedPolynomial poly)
                      =>  Ideal poly -> RationalFunction Rational
hilbertPoincareSeries = hilbertPoincareSeriesBy Grevlex

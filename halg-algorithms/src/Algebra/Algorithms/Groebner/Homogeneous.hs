module Algebra.Algorithms.Groebner.Homogeneous
       ( calcGroebnerBasisAfterHomogenising
       , calcHomogeneousGroebnerBasis
       , unsafeCalcHomogeneousGroebnerBasis
       ) where
import           Algebra.Prelude.Core
import           Algebra.Ring.Polynomial.Homogenised
import           Control.Monad.Loops                 (whileJust_)
import           Control.Monad.ST.Strict
import qualified Data.Foldable                       as F
import           Data.Function                       (on)
import           Data.Heap                           (Entry (..))
import qualified Data.Heap                           as H
import           Data.STRef                          (STRef, modifySTRef',
                                                      newSTRef, readSTRef,
                                                      writeSTRef)
import qualified Data.Vector                         as V
import qualified Data.Vector.Mutable                 as MV

isHomogeneous :: IsOrderedPolynomial poly
              => poly -> Bool
isHomogeneous poly =
  let degs = map F.sum $ F.toList $ monomials poly
  in and $ zipWith (==) degs (tail degs)

-- | Calculates Groebner basis once homogenise, apply @'unsafeCalcHomogeneousGroebnerBasis'@,
--   and then dehomogenise.
calcGroebnerBasisAfterHomogenising :: (Field (Coefficient poly), IsOrderedPolynomial poly)
                  => Ideal poly -> [poly]
calcGroebnerBasisAfterHomogenising i
  | F.all isHomogeneous i = unsafeCalcHomogeneousGroebnerBasis i
  | otherwise = map unhomogenise $ unsafeCalcHomogeneousGroebnerBasis $ fmap homogenise i

-- | Calculates a Groebner basis of the given /homogeneous/ ideal,
--   i.e. an ideal generated by homogeneous polynomials.
--   Returns @'Nothing'@ if the given ideal is inhomogeneous.
--
--   See also @'unsafeCalcHomogeneousGroebnerBasis'@.
calcHomogeneousGroebnerBasis :: (Field (Coefficient poly), IsOrderedPolynomial poly)
                             => Ideal poly -> Maybe [poly]
calcHomogeneousGroebnerBasis i
  | F.all isHomogeneous i = Just $ unsafeCalcHomogeneousGroebnerBasis i
  | otherwise = Nothing

-- | Calculates a Groebner basis of the given /homogeneous/ ideal,
--   i.e. an ideal generated by homogeneous polynomials.
--
--   __N.B.__ This function /DOES NOT/ check homogeniety of the given ideal.
--   See also @'calcHomogeneousGroebnerBasis'@.
unsafeCalcHomogeneousGroebnerBasis :: (Field (Coefficient poly), IsOrderedPolynomial poly)
                             => Ideal poly -> [poly]
unsafeCalcHomogeneousGroebnerBasis ideal = runST $ do
  gs <- newSTRef =<< V.unsafeThaw (V.fromList $ generators ideal)
  sigs <- newSTRef
          =<< buildTable gs [0 .. length (generators ideal) - 1]
  let ins g = do
        j <- snoc gs g
        news <- buildTable gs [j]
        modifySTRef' sigs $ H.union news
  whileJust_ (H.uncons <$> readSTRef sigs) $ \(Entry _ (i, j), h') -> do
    writeSTRef sigs h'
    (fi, fj) <- (,) <$> at gs i <*> at gs j
    gs' <- V.toList <$> (V.unsafeFreeze =<< readSTRef gs)
    let s = sPolynomial fi fj `modPolynomial` gs'
    unless (isZero s) $ ins s
  V.toList <$> (V.unsafeFreeze =<< readSTRef gs)

type Signatures weight = H.Heap (Entry weight (Int, Int))

buildTable :: IsOrderedPolynomial poly
           => RefVec s poly -> [Int] -> ST s (Signatures Int)
buildTable gs inds =
  H.fromList <$> sequence
          [ flip Entry (i, j) <$> deg gs i j
          | j <- inds
          , i <- [0 .. j - 1]
          ]

type RefVec s a = STRef s (MV.MVector s a)

at :: RefVec s a -> Int -> ST s a
at mv i = flip MV.read i =<< readSTRef mv

snoc :: RefVec s a -> a -> ST s Int
snoc ref v = do
  vec <- flip MV.grow 1 =<< readSTRef ref
  let ind = MV.length vec - 1
  MV.write vec ind v
  writeSTRef ref vec
  return ind
{-# INLINE snoc #-}

deg :: IsOrderedPolynomial poly => RefVec s poly -> Int -> Int -> ST s Int
deg gs i j = do
  vec <- readSTRef gs
  (totalDegree .) . (lcmMonomial `on` leadingMonomial)
       <$> MV.read vec i
       <*> MV.read vec j
{-# INLINE deg #-}

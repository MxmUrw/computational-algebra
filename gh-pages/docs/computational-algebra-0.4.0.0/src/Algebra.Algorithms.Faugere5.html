<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE BangPatterns, ConstraintKinds, DataKinds, DeriveDataTypeable    #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts, GADTs, ImplicitParams, MultiParamTypeClasses  #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE NoImplicitPrelude, NoMonomorphismRestriction, ParallelListComp  #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes, ScopedTypeVariables, TemplateHaskell, TupleSections #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators, ViewPatterns                                     #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-unused-do-bind #-}</span><span>
</span><a name="line-7"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Algebra</span><span class="hs-operator">.</span><span class="hs-identifier">Algorithms</span><span class="hs-operator">.</span><span class="hs-identifier">Faugere5</span><span> </span><span class="hs-special">(</span><a href="Algebra.Algorithms.Faugere5.html#f5Original"><span class="hs-identifier hs-var">f5Original</span></a><span class="hs-special">,</span><span> </span><a href="Algebra.Algorithms.Faugere5.html#showSingular"><span class="hs-identifier hs-var">showSingular</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-8"></a><span class="hs-keyword">import</span><span>           </span><a href="Algebra.Algorithms.Groebner.html"><span class="hs-identifier">Algebra</span><span class="hs-operator">.</span><span class="hs-identifier">Algorithms</span><span class="hs-operator">.</span><span class="hs-identifier">Groebner</span></a><span>
</span><a name="line-9"></a><span class="hs-keyword">import</span><span>           </span><a href="Algebra.Prelude.Core.html"><span class="hs-identifier">Algebra</span><span class="hs-operator">.</span><span class="hs-identifier">Prelude</span><span class="hs-operator">.</span><span class="hs-identifier">Core</span></a><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">insert</span><span class="hs-special">)</span><span>
</span><a name="line-10"></a><span>
</span><a name="line-11"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Arrow</span><span>               </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">&gt;&gt;&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-12"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span>                </span><span class="hs-special">(</span><span class="hs-identifier hs-var">makeLenses</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">view</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">%~</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">&amp;</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">.~</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-13"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span>                </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">^.</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">_1</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">_2</span><span class="hs-special">)</span><span>
</span><a name="line-14"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span>               </span><span class="hs-special">(</span><span class="hs-identifier hs-var">filterM</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">forM_</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">liftM</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">when</span><span class="hs-special">)</span><span>
</span><a name="line-15"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span>               </span><span class="hs-special">(</span><span class="hs-identifier hs-var">zipWithM_</span><span class="hs-special">)</span><span>
</span><a name="line-16"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">Loops</span><span>         </span><span class="hs-special">(</span><span class="hs-identifier hs-var">anyM</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">whileM_</span><span class="hs-special">)</span><span>
</span><a name="line-17"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">ST</span><span>            </span><span class="hs-special">(</span><span class="hs-identifier hs-type">ST</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">runST</span><span class="hs-special">)</span><span>
</span><a name="line-18"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">ST</span><span class="hs-operator">.</span><span class="hs-identifier">Unsafe</span><span>     </span><span class="hs-special">(</span><span class="hs-identifier hs-var">unsafeIOToST</span><span class="hs-special">)</span><span>
</span><a name="line-19"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Foldable</span><span>               </span><span class="hs-special">(</span><span class="hs-identifier hs-var">foldrM</span><span class="hs-special">)</span><span>
</span><a name="line-20"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Foldable</span><span>               </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">T</span><span>
</span><a name="line-21"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Function</span><span>               </span><span class="hs-special">(</span><span class="hs-identifier hs-var">on</span><span class="hs-special">)</span><span>
</span><a name="line-22"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Heap</span><span>                   </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Entry</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">insert</span><span class="hs-special">)</span><span>
</span><a name="line-23"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Heap</span><span>                   </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">H</span><span>
</span><a name="line-24"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">IntSet</span><span>                 </span><span class="hs-special">(</span><span class="hs-identifier hs-type">IntSet</span><span class="hs-special">)</span><span>
</span><a name="line-25"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">IntSet</span><span>                 </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">IS</span><span>
</span><a name="line-26"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span>                   </span><span class="hs-special">(</span><span class="hs-identifier hs-var">find</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">partition</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">sort</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">sortBy</span><span class="hs-special">)</span><span>
</span><a name="line-27"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span>                   </span><span class="hs-special">(</span><span class="hs-identifier hs-var">tails</span><span class="hs-special">)</span><span>
</span><a name="line-28"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Maybe</span><span>                  </span><span class="hs-special">(</span><span class="hs-identifier hs-var">listToMaybe</span><span class="hs-special">)</span><span>
</span><a name="line-29"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Monoid</span><span>                 </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-30"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Ord</span><span>                    </span><span class="hs-special">(</span><span class="hs-identifier hs-var">comparing</span><span class="hs-special">)</span><span>
</span><a name="line-31"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">STRef</span><span>                  </span><span class="hs-special">(</span><span class="hs-identifier hs-type">STRef</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">modifySTRef'</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">newSTRef</span><span class="hs-special">)</span><span>
</span><a name="line-32"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">STRef</span><span>                  </span><span class="hs-special">(</span><span class="hs-identifier hs-var">readSTRef</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">writeSTRef</span><span class="hs-special">)</span><span>
</span><a name="line-33"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span>                 </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">V</span><span>
</span><a name="line-34"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Mutable</span><span>         </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">MV</span><span>
</span><a name="line-35"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Decidable</span><span class="hs-operator">.</span><span class="hs-identifier">Zero</span><span>      </span><span class="hs-special">(</span><span class="hs-identifier hs-var">isZero</span><span class="hs-special">)</span><span>
</span><a name="line-36"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Printf</span><span>                 </span><span class="hs-special">(</span><span class="hs-identifier hs-var">printf</span><span class="hs-special">)</span><span>
</span><a name="line-37"></a><span>
</span><a name="line-38"></a><span>
</span><a name="line-39"></a><span class="hs-comment">{-
unsafeIOToST :: Monad m =&gt; t -&gt; m ()
unsafeIOToST _ = return ()
-}</span><span>
</span><a name="line-43"></a><span>
</span><a name="line-44"></a><span class="hs-keyword">type</span><span> </span><a name="CriticalPair"><a href="Algebra.Algorithms.Faugere5.html#CriticalPair"><span class="hs-identifier">CriticalPair</span></a></a><span> </span><a name="local-1629121966"><a href="#local-1629121966"><span class="hs-identifier">ord</span></a></a><span> </span><a name="local-1629121967"><a href="#local-1629121967"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><a href="Algebra.Ring.Polynomial.Monomial.html#OrderedMonomial"><span class="hs-identifier hs-type">OrderedMonomial</span></a><span> </span><a href="#local-1629121966"><span class="hs-identifier hs-type">ord</span></a><span> </span><a href="#local-1629121967"><span class="hs-identifier hs-type">n</span></a><span class="hs-special">,</span><span> </span><a href="Algebra.Ring.Polynomial.Monomial.html#OrderedMonomial"><span class="hs-identifier hs-type">OrderedMonomial</span></a><span> </span><a href="#local-1629121966"><span class="hs-identifier hs-type">ord</span></a><span> </span><a href="#local-1629121967"><span class="hs-identifier hs-type">n</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Int</span><span class="hs-special">,</span><span> </span><a href="Algebra.Ring.Polynomial.Monomial.html#OrderedMonomial"><span class="hs-identifier hs-type">OrderedMonomial</span></a><span> </span><a href="#local-1629121966"><span class="hs-identifier hs-type">ord</span></a><span> </span><a href="#local-1629121967"><span class="hs-identifier hs-type">n</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Int</span><span class="hs-special">)</span><span>
</span><a name="line-45"></a><span class="hs-keyword">type</span><span> </span><a name="Rule"><a href="Algebra.Algorithms.Faugere5.html#Rule"><span class="hs-identifier">Rule</span></a></a><span> </span><a name="local-1629121964"><a href="#local-1629121964"><span class="hs-identifier">ord</span></a></a><span> </span><a name="local-1629121965"><a href="#local-1629121965"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><a href="Algebra.Ring.Polynomial.Monomial.html#OrderedMonomial"><span class="hs-identifier hs-type">OrderedMonomial</span></a><span> </span><a href="#local-1629121964"><span class="hs-identifier hs-type">ord</span></a><span> </span><a href="#local-1629121965"><span class="hs-identifier hs-type">n</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-identifier hs-type">Int</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><a name="line-46"></a><span>
</span><a name="line-47"></a><span class="hs-keyword">data</span><span> </span><a name="PolyRepr"><a href="Algebra.Algorithms.Faugere5.html#PolyRepr"><span class="hs-identifier">PolyRepr</span></a></a><span> </span><a name="local-1629121961"><a href="#local-1629121961"><span class="hs-identifier">r</span></a></a><span> </span><a name="local-1629121962"><a href="#local-1629121962"><span class="hs-identifier">ord</span></a></a><span> </span><a name="local-1629121963"><a href="#local-1629121963"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a name="line-48"></a><span>  </span><a name="PolyRepr"><a href="Algebra.Algorithms.Faugere5.html#PolyRepr"><span class="hs-identifier">PolyRepr</span></a></a><span> </span><span class="hs-special">{</span><span> </span><a name="_signature"><a href="Algebra.Algorithms.Faugere5.html#_signature"><span class="hs-identifier">_signature</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Int</span><span class="hs-special">,</span><span> </span><a href="Algebra.Ring.Polynomial.Monomial.html#OrderedMonomial"><span class="hs-identifier hs-type">OrderedMonomial</span></a><span> </span><a href="#local-1629121962"><span class="hs-identifier hs-type">ord</span></a><span> </span><a href="#local-1629121963"><span class="hs-identifier hs-type">n</span></a><span class="hs-special">)</span><span>
</span><a name="line-49"></a><span>           </span><span class="hs-special">,</span><span> </span><a name="_poly"><a href="Algebra.Algorithms.Faugere5.html#_poly"><span class="hs-identifier">_poly</span></a></a><span>      </span><span class="hs-glyph">::</span><span> </span><a href="Algebra.Ring.Polynomial.html#OrderedPolynomial"><span class="hs-identifier hs-type">OrderedPolynomial</span></a><span> </span><a href="#local-1629121961"><span class="hs-identifier hs-type">r</span></a><span> </span><a href="#local-1629121962"><span class="hs-identifier hs-type">ord</span></a><span> </span><a href="#local-1629121963"><span class="hs-identifier hs-type">n</span></a><span>
</span><a name="line-50"></a><span>           </span><span class="hs-special">}</span><span>
</span><a name="line-51"></a><span>
</span><a name="line-52"></a><span class="hs-identifier">showsIf</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Bool</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">ShowS</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">ShowS</span><span>
</span><a name="line-53"></a><a name="showsIf"><a href="Algebra.Algorithms.Faugere5.html#showsIf"><span class="hs-identifier">showsIf</span></a></a><span> </span><span class="hs-identifier hs-var">True</span><span>  </span><a name="local-1629121968"><a href="#local-1629121968"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-1629121968"><span class="hs-identifier hs-var">a</span></a><span>
</span><a name="line-54"></a><span class="hs-identifier">showsIf</span><span> </span><span class="hs-identifier hs-var">False</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">id</span><span>
</span><a name="line-55"></a><span>
</span><a name="line-56"></a><span class="hs-keyword">instance</span><span> </span><span class="hs-special">(</span><a href="Algebra.Ring.Polynomial.Class.html#CoeffRing"><span class="hs-identifier hs-type">CoeffRing</span></a><span> </span><a href="#local-1629121969"><span class="hs-identifier hs-type">r</span></a><span class="hs-special">,</span><span> </span><a href="Algebra.Ring.Polynomial.Class.html#PrettyCoeff"><span class="hs-identifier hs-type">PrettyCoeff</span></a><span> </span><a href="#local-1629121969"><span class="hs-identifier hs-type">r</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">KnownNat</span><span> </span><a href="#local-1629121970"><span class="hs-identifier hs-type">n</span></a><span class="hs-special">,</span><span> </span><a href="Algebra.Ring.Polynomial.Monomial.html#IsMonomialOrder"><span class="hs-identifier hs-type">IsMonomialOrder</span></a><span> </span><a href="#local-1629121970"><span class="hs-identifier hs-type">n</span></a><span> </span><a href="#local-1629121971"><span class="hs-identifier hs-type">ord</span></a><span class="hs-special">)</span><span>
</span><a name="line-57"></a><span>         </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-identifier hs-type">Show</span><span> </span><span class="hs-special">(</span><a href="Algebra.Algorithms.Faugere5.html#PolyRepr"><span class="hs-identifier hs-type">PolyRepr</span></a><span> </span><a href="#local-1629121969"><span class="hs-identifier hs-type">r</span></a><span> </span><a href="#local-1629121971"><span class="hs-identifier hs-type">ord</span></a><span> </span><a href="#local-1629121970"><span class="hs-identifier hs-type">n</span></a><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-58"></a><span>  </span><a name="local-1912605943"><span class="hs-identifier">showsPrec</span></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-special">(</span><a href="Algebra.Algorithms.Faugere5.html#PolyRepr"><span class="hs-identifier hs-var">PolyRepr</span></a><span> </span><span class="hs-special">(</span><a name="local-1629121972"><a href="#local-1629121972"><span class="hs-identifier">n</span></a></a><span class="hs-special">,</span><span> </span><a name="local-1629121973"><a href="#local-1629121973"><span class="hs-identifier">m</span></a></a><span class="hs-special">)</span><span> </span><a name="local-1629121974"><a href="#local-1629121974"><span class="hs-identifier">p</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">showParen</span><span> </span><span class="hs-identifier hs-var">True</span><span> </span><span class="hs-operator hs-var">$</span><span>
</span><a name="line-59"></a><span>    </span><a href="Algebra.Algorithms.Faugere5.html#showsIf"><span class="hs-identifier hs-var">showsIf</span></a><span> </span><span class="hs-special">(</span><a href="#local-1629121973"><span class="hs-identifier hs-var">m</span></a><span> </span><span class="hs-operator hs-var">/=</span><span> </span><span class="hs-identifier hs-var">one</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">shows</span><span> </span><a href="#local-1629121973"><span class="hs-identifier hs-var">m</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">showChar</span><span> </span><span class="hs-char">' '</span><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">showString</span><span> </span><span class="hs-string">&quot;F_&quot;</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">shows</span><span> </span><a href="#local-1629121972"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">showString</span><span> </span><span class="hs-string">&quot;, &quot;</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">shows</span><span> </span><a href="#local-1629121974"><span class="hs-identifier hs-var">p</span></a><span>
</span><a name="line-60"></a><span>
</span><a name="line-61"></a><span class="hs-keyword">type</span><span> </span><a name="RefVector"><a href="Algebra.Algorithms.Faugere5.html#RefVector"><span class="hs-identifier">RefVector</span></a></a><span> </span><a name="local-1629121959"><a href="#local-1629121959"><span class="hs-identifier">s</span></a></a><span> </span><a name="local-1629121960"><a href="#local-1629121960"><span class="hs-identifier">a</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-type">STRef</span><span> </span><a href="#local-1629121959"><span class="hs-identifier hs-type">s</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">MV</span><span class="hs-operator hs-type">.</span><span class="hs-identifier hs-type">MVector</span><span> </span><a href="#local-1629121959"><span class="hs-identifier hs-type">s</span></a><span> </span><a href="#local-1629121960"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">)</span><span>
</span><a name="line-62"></a><span>
</span><a name="line-63"></a><span class="hs-identifier hs-var">makeLenses</span><span> </span><span class="hs-char">''PolyRepr

instance Eq (PolyRepr r ord n) where
  (==) = (==) `on` view signature

instance (IsMonomialOrder n ord) =&gt; Ord (PolyRepr r ord n) where
  compare = comparing $ view signature

(*@) :: (CoeffRing r, IsMonomialOrder n ord, KnownNat n)
     =&gt; OrderedMonomial ord n -&gt; PolyRepr r ord n -&gt; PolyRepr r ord n
(*@) v = (signature._2 %~ (v*)) &gt;&gt;&gt; (poly %~ (toPolynomial (one, v) *))

nf :: (Eq r, KnownNat n, Field r, IsMonomialOrder n ord)
   =&gt; PolyRepr r ord n -&gt; [OrderedPolynomial r ord n] -&gt; PolyRepr r ord n
nf r g = r &amp; poly %~ (`modPolynomial` g)

infixl 7 *@

preReduction :: (Eq r, KnownNat n, Field r, IsMonomialOrder n order)
             =&gt; [OrderedPolynomial r order n] -&gt; [OrderedPolynomial r order n]
preReduction fs = map monoize $ go [] fs
  where
    go xs []    = xs
    go xs (y:ys) =
      let r = y `modPolynomial` (xs++ys)
      in if r == y
         then go (xs++[y]) ys
         else go [] (xs ++ if isZero r then ys else r : ys)

f5Original :: (PrettyCoeff r, Ord r, KnownNat n, Field r, IsMonomialOrder n ord)
           =&gt; Ideal (OrderedPolynomial r ord n) -&gt; Ideal (OrderedPolynomial r ord n)
f5Original = toIdeal . sort . generators . mainLoop

mainLoop :: (PrettyCoeff r, IsMonomialOrder n ord, CoeffRing r, KnownNat n, Field r)
         =&gt; Ideal (OrderedPolynomial r ord n) -&gt; Ideal (OrderedPolynomial r ord n)
mainLoop (preReduction . filter (not . isZero) . generators -&gt; ij)
  | null ij = toIdeal [zero]
  | otherwise = runST $ do
  let (f0 : fs) =
        sortBy (comparing totalDegree' &lt;&gt; comparing leadingMonomial) ij
  lps0 &lt;- newSTRef =&lt;&lt; V.unsafeThaw (V.singleton (PolyRepr (0, one) f0))
  rs0  &lt;- newSTRef =&lt;&lt; V.unsafeThaw (V.fromList [[]])
  let ?labPolys = lps0
      ?rules    = rs0
  loop [f0] (IS.fromList [0]) fs
  where
    loop bs _ [] = return $ toIdeal bs
    loop bs g (f:xs) = do
      rlen &lt;- lengthMV ?labPolys
      unsafeIOToST $ putStrLn $ show (rlen+1) ++ &quot;th iteration&quot;
      addLabPoly $ PolyRepr (rlen, one) f
      g' &lt;- f5Core rlen bs g
      p  &lt;- anyM (liftM ((== one) . view poly) . readAt ?labPolys) $ IS.toList g'
      if p
        then return $ toIdeal [one]
        else do
        !g'' &lt;- setupReducedBasis g'
        !bs' &lt;- toPolys g''
        -- unsafeIOToST $ putStrLn $ concat
        --  [&quot;reduced(&quot;, show i, &quot;th): &quot;, show (isGroebnerBasis $ toIdeal bs'), &quot;, &quot;, show bs']
        loop bs' g'' xs

interred :: (Eq k, KnownNat n, Field k, IsMonomialOrder n order)
         =&gt; [OrderedPolynomial k order n] -&gt; [OrderedPolynomial k order n]
interred = reduceMinimalGroebnerBasis . minimizeGroebnerBasis

toPolys :: (?labPolys::STRef s (MV.MVector s (PolyRepr r ord n)))
        =&gt; IntSet -&gt; ST s [OrderedPolynomial r ord n]
toPolys = mapM (liftM (view poly) . readAt ?labPolys) . IS.toList

setupReducedBasis :: (Eq r, ?labPolys :: STRef s (MV.MVector s (PolyRepr r ord n)),
                     ?rules :: STRef s (MV.MVector s (Rule ord n)),
                     KnownNat n, Field r, IsMonomialOrder n ord)
                 =&gt; IntSet -&gt; ST s IntSet
setupReducedBasis gs = do
  bs &lt;- interred &lt;$&gt; toPolys gs
  -- unsafeIOToST $ putStr &quot;setup for: &quot; &gt;&gt; print bs
  let count = length bs
      g0 = [0..count-1]
  writeSTRef ?labPolys
    =&lt;&lt; V.unsafeThaw (V.fromList $ [ PolyRepr (j, one) h
                                   | h &lt;- bs
                                   | j &lt;- [0..] ])
  writeSTRef ?rules =&lt;&lt; MV.replicate count []
  zipWithM_ zeroRule (tails bs) [0..]
  return $ IS.fromList g0
  where
    zeroRule []     _ = return ()
    zeroRule (f:fs) j =
      let !t = leadingMonomial f
      in forM_ (zip [j+1..] fs) $ \(k, fk) -&gt; do
        let !u = t / gcdMonomial (leadingMonomial fk) t
        addRule (k, u) Nothing

f5Core :: ( ?labPolys :: (RefVector s (PolyRepr r ord n)),
           ?rules :: (RefVector s (Rule ord n)), PrettyCoeff r,
           Eq r, Field r, KnownNat n, IsMonomialOrder n ord)
       =&gt; Int
       -&gt; [OrderedPolynomial r ord n]
       -&gt; IntSet
       -&gt; ST s IntSet
f5Core i bs g = do
  curIdx &lt;- pred . MV.length &lt;$&gt; readSTRef ?labPolys
  g' &lt;- newSTRef $ IS.insert curIdx g
  ps &lt;- newSTRef =&lt;&lt; mapMaybeM (\j -&gt; criticalPair curIdx j i g) (IS.toList g)
  whileM_ (not . null &lt;$&gt; readSTRef ps) $ do
    p &lt;- readSTRef ps
    let d = minimum $ map (totalDegree.view _1) p
        (pd, p') = partition ((== d) . totalDegree . view _1) p
    unsafeIOToST $ printf &quot;processing %d critical pairs of degree %d\n&quot; (length pd) d
    writeSTRef ps p'
    sd &lt;- spols pd
    rd &lt;- reduction sd bs g =&lt;&lt; readSTRef g'
    forM_ (IS.toList rd) $ \k -&gt; do
      unsafeIOToST . printf &quot;polynomial %d reduced to %s\n&quot; (k+1) . showSingular . view poly =&lt;&lt; readAt ?labPolys k
      pss &lt;- mapMaybeM (\j -&gt; criticalPair j k i g) . IS.toList =&lt;&lt; readSTRef g'
      modifySTRef' ps (pss ++)
      modifySTRef' g' (IS.insert k)
  readSTRef g'

replace :: Eq b =&gt; b -&gt; b -&gt; [b] -&gt; [b]
replace f t = map (\c -&gt; if c == f then t else c)

mapMaybeM :: Monad m =&gt; (t -&gt; m (Maybe a)) -&gt; [t] -&gt; m [a]
mapMaybeM f as = go as id
  where
    go []       acc = return $ acc []
    go (x : xs) acc = do
      ma &lt;- f x
      case ma of
        Nothing -&gt; go xs acc
        Just x' -&gt; go xs (acc . (x' :))

reduction :: (Eq r, ?labPolys :: (RefVector s (PolyRepr r ord n)),
              ?rules :: (RefVector s (Rule ord n)), PrettyCoeff r,
              KnownNat n, Field r,
              IsMonomialOrder n ord)
          =&gt; [Int] -&gt; [OrderedPolynomial r ord n] -&gt; IntSet -&gt; IntSet -&gt; ST s IntSet
reduction t0 bs g g' =
  loop IS.empty . H.fromList =&lt;&lt; mapM (\l -&gt; flip Entry l . view signature &lt;$&gt; readAt ?labPolys l) t0
  where
    loop !completed !todo =
      case H.uncons todo of
        Nothing -&gt; return completed
        Just (Entry _ k, todo') -&gt; do
          rk &lt;- readAt ?labPolys k
          writeAt ?labPolys k $ nf rk bs
          (new, redo) &lt;- topReduction k g (g' `IS.union` completed)
          redo' &lt;- mapM (\l -&gt; flip Entry l . view signature &lt;$&gt; readAt ?labPolys l) redo
          loop (completed `IS.union` IS.fromList new) (todo' `H.union` H.fromList redo')

findReductor :: (CoeffRing r, ?labPolys :: RefVector s (PolyRepr r ord n),
                ?rules :: RefVector s (Rule ord n), KnownNat n,
                IsMonomialOrder n ord)
             =&gt; Int -&gt; IntSet -&gt; IntSet -&gt; ST s (Maybe Int)
findReductor k g g' = do
  rk &lt;- readAt ?labPolys k
  let t = leadingMonomial $! rk ^. poly
      cond j = do
        rj &lt;- readAt ?labPolys j
        let t' = leadingMonomial $ rj ^. poly
            (_, vj) = rj ^. signature
            u  = t/t'
        p1 &lt;- isRewritable u j
        p2 &lt;- isTopReducible (u*vj) g
        return $ t' `divs` t
              -- &amp;&amp; (u *@ rj)^.signature  /= rk ^. signature
              &amp;&amp; not p1 &amp;&amp; not p2
  listToMaybe &lt;$&gt; filterM cond (IS.toList g')

topReduction :: (Eq r, ?labPolys :: (RefVector s (PolyRepr r ord n)),
                 ?rules :: (RefVector s (Rule ord n)), KnownNat n, PrettyCoeff r,
                 Field r, IsMonomialOrder n ord)
             =&gt; Int -&gt; IntSet -&gt; IntSet -&gt; ST s ([Int], [Int])
topReduction k g g' = do
  rk &lt;- readAt ?labPolys k
  let !p = rk ^. poly
  if isZero p
     then do
       unsafeIOToST $ printf &quot;Polynomial %d reduced to zero!\n&quot; (k+1)
       return ([], [])
     else do
  mj &lt;- findReductor k g g'
  case mj of
    Nothing -&gt; do
      writeAt ?labPolys k $ rk &amp; poly %~ monoize
      return ([k], [])
    Just j -&gt;  do
      rj &lt;- readAt ?labPolys j
      let q = rj ^. poly
          u = leadingMonomial p / leadingMonomial q
          c = leadingCoeff p % leadingCoeff q
          p' = monoize $ p - c * toPolynomial (one, u) * q
      if u *@ rj &lt; rk
        then do
          writeAt ?labPolys k $ rk &amp; poly .~ p'
          return ([], [k])
        else do
          n &lt;- lengthMV ?labPolys
          addLabPoly $ (u *@ rj) &amp; poly .~ p'
          unsafeIOToST $
            printf &quot;In topreduction pair (%d,%d) generated polynomial %d:%s\n&quot; (k+1) (j+1) n (showSingular p)
          addRule ((u*@rj) ^. signature) $ Just n
          return ([], [k, n])

spols :: (?labPolys :: (RefVector s (PolyRepr r ord n)),
          ?rules :: (RefVector s (Rule ord n)), Eq r,
          KnownNat n, PrettyCoeff r,
          Field r, IsMonomialOrder n ord)
      =&gt; [CriticalPair ord n] -&gt; ST s [Int]
spols bs =
  map payload . T.toList &lt;$&gt; foldrM step H.empty (sortBy (comparing $ view _1) bs)
  where
    step (_, _, k, _,l) fs = do
      rk &lt;- readAt ?labPolys k
      rl &lt;- readAt ?labPolys l
      let t1 = leadingMonomial $ rk^.poly
          t2 = leadingMonomial $ rl^.poly
          u = t2 / gcdMonomial t1 t2
          v = t1 / gcdMonomial t1 t2
      p1 &lt;- isRewritable u k
      p2 &lt;- isRewritable v l
      if not p1 &amp;&amp; not p2
        then do
          let (fk, fl) = (rk^.poly, rl^.poly)
              s0 = monoize $ leadingCoeff fl % one * toPolynomial (one, u) * fk
                   - leadingCoeff fk %one * toPolynomial (one, v) * fl
              rn = (u *@ rk) &amp; poly .~ s0
          n &lt;- lengthMV ?labPolys
          addLabPoly rn
          --unsafeIOToST $ putStrLn $ concat
          --  [ &quot;spol with: Rule = &quot;, drop 9 $ show rs, &quot;, ((k,u),n) = &quot;, show ((k, u), n)]
          addRule (k, u*(rk^.signature._2)) (Just n)
          if isZero s0
            then return fs
            else do
            count &lt;- lengthMV ?labPolys
            unsafeIOToST $
              printf &quot;In spols pair (%d,%d) generated polynomial %d:%s\n&quot; (k+1) (l+1) count (showSingular s0)
            return $ insert (Entry (rn^.signature) n) fs
        else return fs

addLabPoly :: (?labPolys :: STRef s (MV.MVector s a),
               ?rules :: STRef s (MV.MVector s [a1])) =&gt; a -&gt; ST s ()
addLabPoly r = snoc ?labPolys r &gt;&gt; snoc ?rules []

addRule :: (?rules :: (RefVector s (Rule ord n)))
        =&gt; (Int, OrderedMonomial ord n) -&gt; Maybe Int -&gt; ST s ()
addRule (n, m) k = do
  --unsafeIOToST $ putStr (&quot;\tadding rule for&quot; ++ show ((n,m),k) ++ &quot;: &quot;) &gt;&gt; print cst
  writeAt ?rules n . ((m, k):) =&lt;&lt; readAt ?rules n
  --unsafeIOToST . putStrLn . (&quot;\tnew rule : &quot;++).show =&lt;&lt; V.freeze =&lt;&lt; readSTRef ?rules

isRewritable :: (?labPolys :: (RefVector s (PolyRepr r ord n)),
                 ?rules :: (RefVector s (Rule ord n)))
              =&gt; OrderedMonomial ord n -&gt; Int -&gt; ST s Bool
isRewritable u k = do
  j &lt;- rewrite u k
  return $ Just k /= j

rewrite :: (?labPolys :: (RefVector s (PolyRepr r ord n)),
            ?rules :: (RefVector s (Rule ord n)))
        =&gt; OrderedMonomial ord n -&gt; Int -&gt; ST s (Maybe Int)
rewrite u k = do
  (l, v) &lt;- view signature &lt;$&gt; readAt ?labPolys k
  rs &lt;- readAt ?rules l
  return $ maybe (Just k) snd $ find (\(t, _) -&gt; t `divs` (u * v)) rs

criticalPair :: (?labPolys :: RefVector s (PolyRepr r ord n),
                 ?rules::RefVector s (Rule ord n),
                 CoeffRing r, KnownNat n, IsMonomialOrder n ord)
             =&gt; Int
             -&gt; Int
             -&gt; Int
             -&gt; IntSet
             -&gt; ST s (Maybe (CriticalPair ord n))
criticalPair k l i g = do
  rk &lt;- readAt ?labPolys k
  rl &lt;- readAt ?labPolys l
  let tk = leadingMonomial $ rk^.poly
      tl = leadingMonomial $ rl^.poly
      t  = lcmMonomial tk tl
      tgcd = gcdMonomial tk tl
      u1 = tl / tgcd
      u2 = tk / tgcd
      (k1, t1) = rk ^. signature
      (k2, t2) = rl ^. signature
  p1 &lt;- isTopReducible (u1 * t1) g
  p2 &lt;- isTopReducible (u2 * t2) g
  q1 &lt;- isRewritable u1 k
  q2 &lt;- isRewritable u2 l
  when ((u1 *@ rk)^.signature == (u2 *@ rl)^.signature ||
        k1 == i &amp;&amp; p1 || k2 == i &amp;&amp; p2 || q1 || q2) $ unsafeIOToST $
    printf &quot;  (%d,%d): %s, %s was rejected\n&quot; (k+1) (l+1) (show $ (u1*@rk)^.signature._2) (show $ (u2*@rl)^.signature._2)
  return $! if (u1 *@ rk)^.signature == (u2 *@ rl)^.signature ||
     k1 == i &amp;&amp; p1 || k2 == i &amp;&amp; p2 || q1 || q2
    then Nothing
    else Just $ if (u1 *@ rk)^.signature &lt; (u2 *@ rl)^.signature
         then (t, u2, l, u1, k)
         else (t, u1, k, u2, l)

isTopReducible :: (?labPolys :: RefVector s (PolyRepr r ord n), KnownNat n,
                   CoeffRing r, IsMonomialOrder n ord)
               =&gt; OrderedMonomial ord n -&gt; IntSet -&gt; ST s Bool
isTopReducible f gs =
  anyM (liftM ((`divs` f) . leadingMonomial . view poly) . readAt ?labPolys) (IS.toList gs)

readAt :: STRef s (MV.MVector s b) -&gt; Int -&gt; ST s b
readAt m i = flip MV.read i =&lt;&lt; readSTRef m

writeAt :: STRef s (MV.MVector s a) -&gt; Int -&gt; a -&gt; ST s ()
writeAt m i x = do
  v &lt;- readSTRef m
  MV.write v i x

snoc :: STRef s (MV.MVector s a) -&gt; a -&gt; ST s ()
snoc m x = do
  v &lt;- flip MV.grow 1 =&lt;&lt; readSTRef m
  MV.write v (MV.length v - 1) x
  writeSTRef m v

lengthMV :: STRef s1 (MV.MVector s a) -&gt; ST s1 Int
lengthMV = liftM MV.length . readSTRef

showSingular :: (KnownNat n, IsMonomialOrder n ord, PrettyCoeff r, CoeffRing r)
             =&gt; OrderedPolynomial r ord n -&gt; String
showSingular = replace '%' '/' . showPolynomialWith prettyVars 0
  where
    prettyVars = generate sing $ \o -&gt; &quot;x(&quot; ++ show (fromEnum o) ++ &quot;)&quot;

ideal :: Ideal (OrderedPolynomial (Fraction Integer) Grevlex 3)
ideal = toIdeal
        [4%5 *x^2 *y *z - 5%3 *x^2 *z^2
        ,5%2 *x^4 - 4%5 *x^3 *y
        ,3%5 *x^4 - 3%2 *x^2 *y^2 + 3%5 *x^2 *y *z + 3%5 *y *z^3
        ,-5%4 *x^3 - 4%3 *y^3 + 3%7 *y *z^2]
  where
    [x,y,z] = vars
</span></pre></body></html>
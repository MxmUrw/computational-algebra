<DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;=""><html xmlns="http://www.w3.org/1999/xhtml"><head><link href="style.css" type="text/css" rel="stylesheet"></link><script src="highlight.js" type="text/javascript"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ConstraintKinds, DataKinds, DefaultSignatures     #-}</span><span></span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts, FlexibleInstances, GADTs        #-}</span><span></span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE GeneralizedNewtypeDeriving, MultiParamTypeClasses #-}</span><span></span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE NoMonomorphismRestriction, OverloadedStrings      #-}</span><span></span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE ParallelListComp, PolyKinds, ScopedTypeVariables  #-}</span><span></span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving, TemplateHaskell, TypeFamilies #-}</span><span></span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE TypeSynonymInstances, UndecidableInstances        #-}</span><span></span><a name="line-8"></a><span class="hs-pragma">{-# OPTIONS_GHC -fwarn-name-shadowing #-}</span><span></span><a name="line-9"></a><span class="hs-keyword">module</span><span></span><span class="hs-identifier">Algebra</span><span class="hs-operator">.</span><span class="hs-identifier">Wrapped</span><span></span><span class="hs-special">(</span><a href="Algebra.Wrapped.html#WrappedField"><span class="hs-identifier hs-type">WrappedField</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span></span><a href="Algebra.Wrapped.html#Normed"><span class="hs-identifier hs-type">Normed</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span></span><a href="Algebra.Wrapped.html#WrapCoeff"><span class="hs-identifier hs-type">WrapCoeff</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span></span><a href="Algebra.Wrapped.html#fmapUnwrap"><span class="hs-identifier hs-var">fmapUnwrap</span></a><span class="hs-special">,</span><span></span><a href="Algebra.Wrapped.html#fmapWrap"><span class="hs-identifier hs-var">fmapWrap</span></a><span class="hs-special">)</span><span></span><span class="hs-keyword">where</span><span></span><a name="line-10"></a><span class="hs-keyword">import</span><span></span><a href="Algebra.Scalar.html"><span class="hs-identifier">Algebra</span><span class="hs-operator">.</span><span class="hs-identifier">Scalar</span></a><span></span><a name="line-11"></a><span class="hs-keyword">import</span><span></span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span></span><a name="line-12"></a><span class="hs-keyword">import</span><span></span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Complex</span><span></span><a name="line-13"></a><span class="hs-keyword">import</span><span></span><span class="hs-keyword">qualified</span><span></span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Ratio</span><span></span><span class="hs-keyword">as</span><span></span><span class="hs-identifier">P</span><span></span><a name="line-14"></a><span class="hs-keyword">import</span><span></span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Algebra</span><span></span><span class="hs-keyword">hiding</span><span></span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">/</span><span class="hs-special">)</span><span class="hs-special">,</span><span></span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span></span><a name="line-15"></a><span class="hs-keyword">import</span><span></span><span class="hs-keyword">qualified</span><span></span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Algebra</span><span></span><span class="hs-keyword">as</span><span></span><span class="hs-identifier">NA</span><span></span><a name="line-16"></a><span class="hs-keyword">import</span><span></span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Domain</span><span class="hs-operator">.</span><span class="hs-identifier">Euclidean</span><span></span><span class="hs-special">(</span><span class="hs-identifier hs-type">Euclidean</span><span class="hs-special">)</span><span></span><a name="line-17"></a><span class="hs-keyword">import</span><span></span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Field</span><span class="hs-operator">.</span><span class="hs-identifier">Fraction</span><span></span><span class="hs-special">(</span><span class="hs-identifier hs-type">Fraction</span><span class="hs-special">,</span><span></span><span class="hs-identifier hs-var">numerator</span><span class="hs-special">,</span><span></span><span class="hs-special">(</span><span class="hs-operator hs-var">%</span><span class="hs-special">)</span><span class="hs-special">)</span><span></span><a name="line-18"></a><span class="hs-keyword">import</span><span></span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">Field</span><span class="hs-operator">.</span><span class="hs-identifier">Fraction</span><span></span><span class="hs-special">(</span><span class="hs-identifier hs-var">denominator</span><span class="hs-special">)</span><span></span><a name="line-19"></a><span class="hs-keyword">import</span><span></span><span class="hs-identifier">Prelude</span><span></span><span class="hs-keyword">hiding</span><span></span><span class="hs-special">(</span><span class="hs-identifier hs-var">lex</span><span class="hs-special">,</span><span></span><span class="hs-identifier hs-var">negate</span><span class="hs-special">,</span><span></span><span class="hs-identifier hs-var">recip</span><span class="hs-special">,</span><span></span><span class="hs-identifier hs-var">sum</span><span class="hs-special">,</span><span></span><span class="hs-special">(</span><span class="hs-operator hs-var">*</span><span class="hs-special">)</span><span class="hs-special">,</span><span></span><a name="line-20"></a><span></span><span class="hs-special">(</span><span class="hs-operator hs-var">+</span><span class="hs-special">)</span><span class="hs-special">,</span><span></span><span class="hs-special">(</span><span class="hs-glyph">-</span><span class="hs-special">)</span><span class="hs-special">,</span><span></span><span class="hs-special">(</span><span class="hs-operator hs-var">^</span><span class="hs-special">)</span><span class="hs-special">,</span><span></span><span class="hs-special">(</span><span class="hs-operator hs-var">^^</span><span class="hs-special">)</span><span class="hs-special">)</span><span></span><a name="line-21"></a><span class="hs-keyword">import</span><span></span><span class="hs-keyword">qualified</span><span></span><span class="hs-identifier">Prelude</span><span></span><span class="hs-keyword">as</span><span></span><span class="hs-identifier">P</span><span></span><a name="line-22"></a><span class="hs-keyword">import</span><span></span><span class="hs-identifier">Unsafe</span><span class="hs-operator">.</span><span class="hs-identifier">Coerce</span><span></span><a name="line-23"></a><span></span><a name="line-24"></a><span class="hs-keyword">newtype</span><span></span><a name="WrappedField"><a href="Algebra.Wrapped.html#WrappedField"><span class="hs-identifier">WrappedField</span></a></a><span></span><a name="local-1627777805"><a href="#local-1627777805"><span class="hs-identifier">a</span></a></a><span></span><span class="hs-glyph">=</span><span></span><a name="WrapField"><a href="Algebra.Wrapped.html#WrapField"><span class="hs-identifier">WrapField</span></a></a><span></span><span class="hs-special">{</span><span></span><a name="unwrapField"><a href="Algebra.Wrapped.html#unwrapField"><span class="hs-identifier">unwrapField</span></a></a><span></span><span class="hs-glyph">::</span><span></span><a href="#local-1627777805"><span class="hs-identifier hs-type">a</span></a><span></span><a name="line-25"></a><span></span><span class="hs-special">}</span><span></span><span class="hs-keyword">deriving</span><span></span><span class="hs-special">(</span><span class="hs-identifier hs-type">Read</span><span class="hs-special">,</span><span></span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span></span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span></span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">)</span><span></span><a name="line-26"></a><span></span><a name="line-27"></a><span class="hs-identifier hs-var">makeWrapped</span><span></span><span class="hs-char">&#39;&#39;WrappedField

deriving instance Commutative r =&gt; Commutative (WrappedField r)
deriving instance Ring r =&gt; Ring (WrappedField r)
deriving instance Additive r =&gt; Additive (WrappedField r)
deriving instance Multiplicative r =&gt; Multiplicative (WrappedField r)
deriving instance Unital r =&gt; Unital (WrappedField r)
deriving instance DecidableUnits r =&gt; DecidableUnits (WrappedField r)
deriving instance Division r =&gt; Division (WrappedField r)
deriving instance Semiring r =&gt; Semiring (WrappedField r)
deriving instance Abelian r =&gt; Abelian (WrappedField r)
deriving instance Rig r =&gt; Rig (WrappedField r)

instance LeftModule a r =&gt; LeftModule a (WrappedField r) where
  n .* WrapField r = WrapField $ n .* r

instance RightModule a r =&gt; RightModule a (WrappedField r) where
  WrapField r *. n = WrapField $ r *. n

deriving instance Monoidal r =&gt; Monoidal (WrappedField r)
deriving instance Group r =&gt; Group (WrappedField r)
deriving instance DecidableZero r =&gt; DecidableZero (WrappedField r)

class Ord (Norm a) =&gt; Normed a where
  type Norm a
  norm :: a -&gt; Norm a
  liftNorm :: Norm a -&gt; a

instance Normed a =&gt; Normed (WrappedField a) where
  type Norm (WrappedField a) = Norm a
  norm = norm . unwrapField
  liftNorm = WrapField . liftNorm

instance Normed Double where
  type Norm Double = Double
  norm a = abs a
  liftNorm = id

instance Normed Int where
  type Norm Int = Int
  norm = abs
  liftNorm = id

instance Normed Integer where
  type Norm Integer = Integer
  norm = abs
  liftNorm = id

instance (Ord (Norm d), Euclidean d, Euclidean (Norm d), Normed d)
     =&gt;  Normed (Fraction d) where
  type Norm (Fraction d) = Fraction (Norm d)
  norm f = norm (numerator f) % norm (denominator f)
  liftNorm f = liftNorm (numerator f) % liftNorm (denominator f)

instance (Monoidal a, Normed a, Additive (Norm a)) =&gt; Normed (Complex a) where
  type Norm (Complex a) = Norm a
  norm (a :+ b) = norm a + norm b
  liftNorm = (:+ zero) . liftNorm

instance (Eq r, Division r, Group r, Ring r, Normed r)
         =&gt; Num (WrappedField r) where
  WrapField a + WrapField b = WrapField $ a + b
  WrapField a - WrapField b = WrapField $ a - b
  WrapField a * WrapField b = WrapField $ a * b
  negate = _Unwrapping WrapField %~ negate
  fromInteger = WrapField . NA.fromInteger
  abs n = liftNorm (norm n)
  signum n | abs n == zero = zero
           | otherwise = n NA./ abs n

instance (Normed r, Eq r, Ring r, Division r, Group r) =&gt; Fractional (WrappedField r) where
  WrapField a / WrapField b = WrapField $ a NA./ b
  recip (WrapField a) = WrapField $ NA.recip a
  fromRational q = WrapField $ NA.fromInteger (P.numerator q) NA./ NA.fromInteger (P.denominator q)

fmapUnwrap :: Functor f =&gt; f (WrappedField r) -&gt; f r
fmapUnwrap = fmap unsafeCoerce

fmapWrap :: Functor f =&gt; f r -&gt; f (WrappedField r)
fmapWrap = fmap unsafeCoerce

{-# RULES
&quot;fmap/wrap&quot;   forall (x :: Functor f =&gt; f r) . fmap WrapField   x = fmapWrap x
  #-}

newtype WrapCoeff a = WrapCoeff { runCoeff :: a }
                deriving (Abelian, Additive, Multiplicative,
                          Semiring, Unital, Commutative, Show, Eq, Ord)

deriving instance Monoidal a =&gt; Monoidal (WrapCoeff a)
deriving instance Ring a  =&gt; Ring (WrapCoeff a)
deriving instance (Rig a) =&gt; Rig (WrapCoeff a)
deriving instance Group a =&gt; Group (WrapCoeff a)
deriving instance {-# OVERLAPPING #-} RightModule Natural a =&gt; RightModule Natural (WrapCoeff a)
deriving instance {-# OVERLAPPING #-} LeftModule  Natural a =&gt; LeftModule  Natural (WrapCoeff a)
deriving instance {-# OVERLAPPING #-} RightModule Integer a =&gt; RightModule Integer (WrapCoeff a)
deriving instance {-# OVERLAPPING #-} LeftModule Integer a =&gt; LeftModule Integer (WrapCoeff a)

makeWrapped &#39;&#39;WrapCoeff

instance {-# INCOHERENT #-} Semiring a =&gt; LeftModule (Scalar a) (WrapCoeff a) where
  Scalar a .* WrapCoeff b = WrapCoeff $ a * b
  {-# INLINE (.*) #-}

instance {-# INCOHERENT #-} Semiring a =&gt; RightModule (Scalar a) (WrapCoeff a) where
  WrapCoeff b *. Scalar a = WrapCoeff (b * a)
  {-# INLINE (*.) #-}
</span></pre></body></html></DOCTYPE>
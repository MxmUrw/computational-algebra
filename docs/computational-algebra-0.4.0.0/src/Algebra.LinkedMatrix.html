<DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;=""><html xmlns="http://www.w3.org/1999/xhtml"><head><link href="style.css" type="text/css" rel="stylesheet"></link><script src="highlight.js" type="text/javascript"></script></head><body><pre><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-name-shadowing #-}</span> <span></span> <a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE BangPatterns, DataKinds, FlexibleContexts, FlexibleInstances  #-}</span> <span></span> <a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE GADTs, GeneralizedNewtypeDeriving, KindSignatures, LambdaCase #-}</span> <span></span> <a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses, NamedFieldPuns, NoImplicitPrelude      #-}</span> <span></span> <a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE NoMonomorphismRestriction, PolyKinds, RankNTypes              #-}</span> <span></span> <a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables, StandaloneDeriving, TemplateHaskell      #-}</span> <span></span> <a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE TupleSections, UndecidableInstances, ViewPatterns             #-}</span> <span></span> <a name="line-8"></a><span class="hs-pragma">{-# OPTIONS_GHC -funbox-strict-fields -Wno-type-defaults -Wno-redundant-constraints #-}</span> <span></span> <a name="line-9"></a><span class="hs-keyword">module</span> <span></span> <span class="hs-identifier">Algebra</span> <span class="hs-operator">.</span> <span class="hs-identifier">LinkedMatrix</span> <span></span> <span class="hs-special">(</span> <a href="Algebra.LinkedMatrix.html#Matrix"><span class="hs-identifier hs-type">Matrix</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#toLists"><span class="hs-identifier hs-var">toLists</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#fromLists"><span class="hs-identifier hs-var">fromLists</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#fromList"><span class="hs-identifier hs-var">fromList</span> </a><span class="hs-special">,</span> <span></span> <a name="line-10"></a><span></span> <a href="Algebra.LinkedMatrix.html#swapRows"><span class="hs-identifier hs-var">swapRows</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#identity"><span class="hs-identifier hs-var">identity</span> </a><span class="hs-special">,</span> <a href="Algebra.LinkedMatrix.html#nonZeroRows"><span class="hs-identifier hs-var">nonZeroRows</span> </a><span class="hs-special">,</span> <a href="Algebra.LinkedMatrix.html#nonZeroCols"><span class="hs-identifier hs-var">nonZeroCols</span> </a><span class="hs-special">,</span> <span></span> <a name="line-11"></a><span></span> <a href="Algebra.LinkedMatrix.html#swapCols"><span class="hs-identifier hs-var">swapCols</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#switchCols"><span class="hs-identifier hs-var">switchCols</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#switchRows"><span class="hs-identifier hs-var">switchRows</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#addRow"><span class="hs-identifier hs-var">addRow</span> </a><span class="hs-special">,</span> <span></span> <a name="line-12"></a><span></span> <a href="Algebra.LinkedMatrix.html#addCol"><span class="hs-identifier hs-var">addCol</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#ncols"><span class="hs-identifier hs-var">ncols</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#nrows"><span class="hs-identifier hs-var">nrows</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#getRow"><span class="hs-identifier hs-var">getRow</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#getCol"><span class="hs-identifier hs-var">getCol</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#triangulateModular"><span class="hs-identifier hs-var">triangulateModular</span> </a><span class="hs-special">,</span> <span></span> <a name="line-13"></a><span></span> <a href="Algebra.LinkedMatrix.html#scaleRow"><span class="hs-identifier hs-var">scaleRow</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#combineRows"><span class="hs-identifier hs-var">combineRows</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#combineCols"><span class="hs-identifier hs-var">combineCols</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#transpose"><span class="hs-identifier hs-var">transpose</span> </a><span class="hs-special">,</span> <span></span> <a name="line-14"></a><span></span> <a href="Algebra.LinkedMatrix.html#inBound"><span class="hs-identifier hs-var">inBound</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#height"><span class="hs-identifier hs-var">height</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#width"><span class="hs-identifier hs-var">width</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#cmap"><span class="hs-identifier hs-var">cmap</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#empty"><span class="hs-identifier hs-var">empty</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#rowVector"><span class="hs-identifier hs-var">rowVector</span> </a><span class="hs-special">,</span> <span></span> <a name="line-15"></a><span></span> <a href="Algebra.LinkedMatrix.html#colVector"><span class="hs-identifier hs-var">colVector</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#rowCount"><span class="hs-identifier hs-var">rowCount</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#colCount"><span class="hs-identifier hs-var">colCount</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#traverseRow"><span class="hs-identifier hs-var">traverseRow</span> </a><span class="hs-special">,</span> <span></span> <a name="line-16"></a><span></span> <a href="Algebra.LinkedMatrix.html#traverseCol"><span class="hs-identifier hs-var">traverseCol</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#Entry"><span class="hs-identifier hs-type">Entry</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#idx"><span class="hs-identifier hs-var">idx</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#value"><span class="hs-identifier hs-var">value</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#substMatrix"><span class="hs-identifier hs-var">substMatrix</span> </a><span class="hs-special">,</span> <span></span> <a name="line-17"></a><span></span> <a href="Algebra.LinkedMatrix.html#catRow"><span class="hs-identifier hs-var">catRow</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#catCol"><span class="hs-identifier hs-var">catCol</span> </a><span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <a href="Algebra.LinkedMatrix.html#%3C%7C%7C%3E"><span class="hs-operator hs-var">&lt;||&gt;</span> </a><span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <a href="Algebra.LinkedMatrix.html#%3C--%3E"><span class="hs-operator hs-var">&lt;--&gt;</span> </a><span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#toRows"><span class="hs-identifier hs-var">toRows</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#toCols"><span class="hs-identifier hs-var">toCols</span> </a><span class="hs-special">,</span> <span></span> <a name="line-18"></a><span></span> <a href="Algebra.LinkedMatrix.html#zeroMat"><span class="hs-identifier hs-var">zeroMat</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#getDiag"><span class="hs-identifier hs-var">getDiag</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#trace"><span class="hs-identifier hs-var">trace</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#diagProd"><span class="hs-identifier hs-var">diagProd</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#diag"><span class="hs-identifier hs-var">diag</span> </a><span class="hs-special">,</span> <span></span> <a name="line-19"></a><span></span> <a href="Algebra.LinkedMatrix.html#scaleCol"><span class="hs-identifier hs-var">scaleCol</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#clearRow"><span class="hs-identifier hs-var">clearRow</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#clearCol"><span class="hs-identifier hs-var">clearCol</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#index"><span class="hs-identifier hs-var">index</span> </a><span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">!</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a name="line-20"></a><span></span> <a href="Algebra.LinkedMatrix.html#nonZeroEntries"><span class="hs-identifier hs-var">nonZeroEntries</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#rankLM"><span class="hs-identifier hs-var">rankLM</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#splitIndependentDirs"><span class="hs-identifier hs-var">splitIndependentDirs</span> </a><span class="hs-special">,</span> <span></span> <a name="line-21"></a><span></span> <a href="Algebra.LinkedMatrix.html#structuredGauss"><span class="hs-identifier hs-var">structuredGauss</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#multWithVector"><span class="hs-identifier hs-var">multWithVector</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#solveWiedemann"><span class="hs-identifier hs-var">solveWiedemann</span> </a><span class="hs-special">,</span> <span></span> <a name="line-22"></a><span></span> <a href="Algebra.LinkedMatrix.html#henselLift"><span class="hs-identifier hs-var">henselLift</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#solveHensel"><span class="hs-identifier hs-var">solveHensel</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.LinkedMatrix.html#structuredGauss%27"><span class="hs-identifier hs-var">structuredGauss&#39;</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-keyword">where</span> <span></span> <a name="line-23"></a><span class="hs-keyword">import</span> <span></span> <a href="Algebra.Algorithms.ChineseRemainder.html"><span class="hs-identifier">Algebra</span> <span class="hs-operator">.</span> <span class="hs-identifier">Algorithms</span> <span class="hs-operator">.</span> <span class="hs-identifier">ChineseRemainder</span> </a><span></span> <a name="line-24"></a><span class="hs-keyword">import</span> <span></span> <a href="Algebra.Field.Finite.html"><span class="hs-identifier">Algebra</span> <span class="hs-operator">.</span> <span class="hs-identifier">Field</span> <span class="hs-operator">.</span> <span class="hs-identifier">Finite</span> </a><span></span> <a name="line-25"></a><span class="hs-keyword">import</span> <span></span> <a href="Algebra.Instances.html"><span class="hs-identifier">Algebra</span> <span class="hs-operator">.</span> <span class="hs-identifier">Instances</span> </a><span></span> <span class="hs-special">(</span> <span class="hs-special">)</span> <span></span> <a name="line-26"></a><span class="hs-keyword">import</span> <span></span> <a href="Algebra.Prelude.html"><span class="hs-identifier">Algebra</span> <span class="hs-operator">.</span> <span class="hs-identifier">Prelude</span> </a><span></span> <span class="hs-keyword">hiding</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Vector</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">empty</span> <span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#fromList"><span class="hs-identifier hs-var">fromList</span> </a><span class="hs-special">,</span> <span></span> <a name="line-27"></a><span></span> <span class="hs-identifier hs-var">generate</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">insert</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">transpose</span> <span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <a href="Algebra.Prelude.html#%25"><span class="hs-operator hs-var">%</span> </a><span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a name="line-28"></a><span></span> <span class="hs-special">(</span> <span class="hs-operator hs-var">&lt;.&gt;</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <span class="hs-operator hs-var">&lt;&gt;</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-29"></a><span></span> <a name="line-30"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Applicative</span> <span></span> <span class="hs-special">(</span> <span class="hs-special">(</span> <span class="hs-operator hs-var">&lt;|&gt;</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-31"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Arrow</span> <span></span> <span class="hs-special">(</span> <span class="hs-special">(</span> <span class="hs-operator hs-var">&amp;&amp;&amp;</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-32"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Arrow</span> <span></span> <span class="hs-special">(</span> <span class="hs-special">(</span> <span class="hs-operator hs-var">&gt;&gt;&gt;</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-33"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Lens</span> <span></span> <span class="hs-keyword">hiding</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">index</span> <span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <span class="hs-operator hs-var">&lt;.&gt;</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-34"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monad</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">replicateM</span> <span class="hs-special">)</span> <span></span> <a name="line-35"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monad</span> <span class="hs-operator">.</span> <span class="hs-identifier">Loops</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">iterateUntil</span> <span class="hs-special">)</span> <span></span> <a name="line-36"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monad</span> <span class="hs-operator">.</span> <span class="hs-identifier">Random</span> <span></span> <span class="hs-keyword">hiding</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">fromList</span> <span class="hs-special">)</span> <span></span> <a name="line-37"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monad</span> <span class="hs-operator">.</span> <span class="hs-identifier">ST</span> <span class="hs-operator">.</span> <span class="hs-identifier">Strict</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">ST</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">runST</span> <span class="hs-special">)</span> <span></span> <a name="line-38"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monad</span> <span class="hs-operator">.</span> <span class="hs-identifier">State</span> <span class="hs-operator">.</span> <span class="hs-identifier">Strict</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">evalState</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">runState</span> <span class="hs-special">)</span> <span></span> <a name="line-39"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Parallel</span> <span class="hs-operator">.</span> <span class="hs-identifier">Strategies</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">parMap</span> <span class="hs-special">)</span> <span></span> <a name="line-40"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Parallel</span> <span class="hs-operator">.</span> <span class="hs-identifier">Strategies</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">rdeepseq</span> <span class="hs-special">)</span> <span></span> <a name="line-41"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">IntMap</span> <span class="hs-operator">.</span> <span class="hs-identifier">Strict</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">IntMap</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">alter</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">insert</span> <span class="hs-special">,</span> <span></span> <a name="line-42"></a><span></span> <span class="hs-identifier hs-var">mapMaybeWithKey</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">minViewWithKey</span> <span class="hs-special">)</span> <span></span> <a name="line-43"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">IntMap</span> <span class="hs-operator">.</span> <span class="hs-identifier">Strict</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">IM</span> <span></span> <a name="line-44"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">IntSet</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">IntSet</span> <span class="hs-special">)</span> <span></span> <a name="line-45"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">IntSet</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">IS</span> <span></span> <a name="line-46"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">List</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">minimumBy</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">sort</span> <span class="hs-special">)</span> <span></span> <a name="line-47"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">List</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">sortBy</span> <span class="hs-special">)</span> <span></span> <a name="line-48"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Maybe</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">fromJust</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">fromMaybe</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">mapMaybe</span> <span class="hs-special">)</span> <span></span> <a name="line-49"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monoid</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">First</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-50"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Numbers</span> <span class="hs-operator">.</span> <span class="hs-identifier">Primes</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">primes</span> <span class="hs-special">)</span> <span></span> <a name="line-51"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Ord</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">comparing</span> <span class="hs-special">)</span> <span></span> <a name="line-52"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Proxy</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Proxy</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-53"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Reflection</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Reifies</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">reify</span> <span class="hs-special">)</span> <span></span> <a name="line-54"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Semigroup</span> <span></span> <span class="hs-keyword">hiding</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">First</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-55"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Tuple</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">swap</span> <span class="hs-special">)</span> <span></span> <a name="line-56"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Vector</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Vector</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">create</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">generate</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">thaw</span> <span class="hs-special">,</span> <span></span> <a name="line-57"></a><span></span> <span class="hs-identifier hs-var">unsafeFreeze</span> <span class="hs-special">)</span> <span></span> <a name="line-58"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Vector</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">V</span> <span></span> <a name="line-59"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Vector</span> <span class="hs-operator">.</span> <span class="hs-identifier">Mutable</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">grow</span> <span class="hs-special">)</span> <span></span> <a name="line-60"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Vector</span> <span class="hs-operator">.</span> <span class="hs-identifier">Mutable</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">MV</span> <span></span> <a name="line-61"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Numeric</span> <span class="hs-operator">.</span> <span class="hs-identifier">Decidable</span> <span class="hs-operator">.</span> <span class="hs-identifier">Zero</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">isZero</span> <span class="hs-special">)</span> <span></span> <a name="line-62"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Numeric</span> <span class="hs-operator">.</span> <span class="hs-identifier">Domain</span> <span class="hs-operator">.</span> <span class="hs-identifier">GCD</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">gcd</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">lcm</span> <span class="hs-special">)</span> <span></span> <a name="line-63"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Numeric</span> <span class="hs-operator">.</span> <span class="hs-identifier">Field</span> <span class="hs-operator">.</span> <span class="hs-identifier">Fraction</span> <span></span> <a name="line-64"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Numeric</span> <span class="hs-operator">.</span> <span class="hs-identifier">Semiring</span> <span class="hs-operator">.</span> <span class="hs-identifier">ZeroProduct</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">ZeroProductSemiring</span> <span class="hs-special">)</span> <span></span> <a name="line-65"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">P</span> <span></span> <a name="line-66"></a><span></span> <a name="line-67"></a><span class="hs-keyword">data</span> <span></span> <a name="Entry"><a href="Algebra.LinkedMatrix.html#Entry"><span class="hs-identifier">Entry</span> </a></a><span></span> <a name="local-1632596482"><a href="#local-1632596482"><span class="hs-identifier">a</span> </a></a><span></span> <span class="hs-glyph">=</span> <span></span> <a name="Entry"><a href="Algebra.LinkedMatrix.html#Entry"><span class="hs-identifier">Entry</span> </a></a><span></span> <span class="hs-special">{</span> <span></span> <a name="_value"><a href="Algebra.LinkedMatrix.html#_value"><span class="hs-identifier">_value</span> </a></a><span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-glyph">!</span> <a href="#local-1632596482"><span class="hs-identifier hs-type">a</span> </a><span></span> <a name="line-68"></a><span></span> <span class="hs-special">,</span> <span></span> <a name="_idx"><a href="Algebra.LinkedMatrix.html#_idx"><span class="hs-identifier">_idx</span> </a></a><span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-glyph">!</span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Int</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Int</span> <span class="hs-special">)</span> <span></span> <a name="line-69"></a><span></span> <span class="hs-special">,</span> <span></span> <a name="_rowNext"><a href="Algebra.LinkedMatrix.html#_rowNext"><span class="hs-identifier">_rowNext</span> </a></a><span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-glyph">!</span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Maybe</span> <span></span> <span class="hs-identifier hs-type">Int</span> <span class="hs-special">)</span> <span></span> <a name="line-70"></a><span></span> <span class="hs-special">,</span> <span></span> <a name="_colNext"><a href="Algebra.LinkedMatrix.html#_colNext"><span class="hs-identifier">_colNext</span> </a></a><span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-glyph">!</span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Maybe</span> <span></span> <span class="hs-identifier hs-type">Int</span> <span class="hs-special">)</span> <span></span> <a name="line-71"></a><span></span> <span class="hs-special">}</span> <span></span> <span class="hs-keyword">deriving</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Read</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Show</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Eq</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Ord</span> <span class="hs-special">)</span> <span></span> <a name="line-72"></a><span></span> <a name="line-73"></a><span class="hs-identifier hs-var">makeLenses</span> <span></span> <span class="hs-char">&#39;&#39;Entry

newEntry :: a -&gt; Entry a
newEntry v = Entry v (-1,-1) Nothing Nothing

data Matrix a = Matrix { _coefficients :: !(Vector (Entry a))
                       , _rowStart     :: !(IntMap Int)
                       , _colStart     :: !(IntMap Int)
                       , _height       :: !Int
                       , _width        :: !Int
                       } deriving (Read, Show)

makeLenses &#39;&#39;Matrix

data BuildState = BuildState { _colMap :: !(IntMap Int)
                             , _rowMap :: !(IntMap Int)
                             , _curIdx :: !Int
                             }
makeLenses &#39;&#39;BuildState

data GaussianState a = GaussianState { _input     :: !(Matrix a)
                                     , _output    :: !(Matrix a)
                                     , _prevCol   :: !Int
                                     , _heavyCols :: !IntSet
                                     , _curRow    :: !Int
                                     , _detAcc    :: !a
                                     }
makeLenses &#39;&#39;GaussianState

instance Eq a =&gt; Eq (Matrix a) where
  n == m =
    n^.height == m^.height &amp;&amp; n^.width == m^.width &amp;&amp; content n == content m
    where
      content = sortBy (comparing fst) . V.toList . nonZeroEntries

data MaxEntry a b = MaxEntry { _weight :: !a
                             , entry   :: b
                             } deriving (Read, Show, Eq, Ord)

empty :: Matrix a
empty = Matrix V.empty IM.empty IM.empty 0 0

fromLists :: DecidableZero a =&gt; [[a]] -&gt; Matrix a
fromLists xss =
  fromList (concat $ zipWith (\i -&gt; zipWith (\j -&gt; ((i,j),)) [0..]) [0..] xss)
  &amp; width  .~ maximum (0 : map length xss)
  &amp; height .~ length xss

fromCols :: DecidableZero a =&gt; [Vector a] -&gt; Matrix a
fromCols xss =
  let h = maximum $ map V.length xss
      w = length xss
  in fromList (concat $ zipWith (\i -&gt; V.toList . V.imap (\j -&gt; ((j,i),))) [0..] xss)
     &amp; width .~ w
     &amp; height .~ h

fromList :: DecidableZero a =&gt; [((Int, Int), a)] -&gt; Matrix a
fromList cs =
  let (as, bs) = runState (mapM initialize $ filter (view $ _2 . to (not.isZero)) cs)
                 (BuildState IM.empty IM.empty (-1))
      vec = V.fromList as
      h = maximum (0:map (view $ _1._1) cs) + 1
      w = maximum (0:map (view $ _1._2) cs) + 1
  in Matrix vec (bs^.rowMap) (bs^.colMap) h w
  where
    initialize ((i, j), c) =  do
        curIdx += 1
        n &lt;- use curIdx
        nc &lt;- use $ colMap.at j
        nr &lt;- use $ rowMap.at i
        colMap %= insert j n
        rowMap %= insert i n
        return $ Entry { _value = c
                       , _idx = (i, j)
                       , _rowNext = nr
                       , _colNext = nc
                       }


getDiag :: Monoidal a =&gt; Matrix a -&gt; Vector a
getDiag mat = V.generate (min (mat^.height) (mat^.width)) $ \i -&gt;
  fromMaybe zero $ traverseDir Nothing (\a _ e -&gt; a &lt;|&gt; if i == e^.nthL Row
                                                        then Just (e^.value )
                                                        else Nothing) Row i mat

diagProd :: (Unital c, Monoidal c) =&gt; Matrix c -&gt; c
diagProd = V.foldr&#39; (*) one . getDiag

trace :: Monoidal c =&gt; Matrix c -&gt; c
trace = V.foldr&#39; (+) zero . getDiag

toLists :: forall a. Monoidal a =&gt; Matrix a -&gt; [[a]]
toLists mat =
  let orig = replicate (_height mat) $ replicate (_width mat) (zero :: a)
  in go (V.toList $ _coefficients mat) orig
  where
    go [] m = m
    go (Entry{_value = v, _idx = (i,j) }:es) m =
      go es (m&amp;ix i.ix j .~ v)

swapRows :: Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
swapRows = swapper Row

swapCols :: Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
swapCols = swapper Column

swapper :: Direction -&gt; Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
swapper dir i j mat =
  let ith = mat^.startL dir.at i
      jth = mat^.startL dir.at j
  in  mat &amp; startL dir   %~ alter (const jth) i . alter (const ith) j
          &amp; coefficients %~ go ith . go jth
  where
    go Nothing v = v
    go (Just k) vec =
      let !cur = vec V.! k
      in go (cur ^. nextL dir) (vec &amp; ix k . coordL dir %~ change)
    change k | k == i = j
             | k == j = i
             | otherwise = k

scaleDir :: (DecidableZero a, Multiplicative a) =&gt; Direction -&gt; a -&gt; Int -&gt; Matrix a -&gt; Matrix a
scaleDir dir a i mat
  | otherwise = mapDir (*a) dir i mat
  | isZero a  = clearDir dir i mat

clearAt :: Int -&gt; Matrix a -&gt; Matrix a
clearAt k mat = mat &amp; coefficients %~ go
                    &amp; forwardStart Column
                    &amp; forwardStart Row
  where
    !old = ((mat ^. coefficients) V.! k)
           &amp; colNext._Just %~ shifter
           &amp; rowNext._Just %~ shifter
    forwardStart dir =
      let l = (old ^. coordL dir)
      in startL dir %~ mapMaybeWithKey
                       (\d v -&gt; if d == l &amp;&amp; v == k
                                then old ^. nextL dir
                                else Just $ shifter v)
    shiftDir sel = nextL sel %~ \case
      Nothing -&gt; Nothing
      Just l -&gt;
        if l == k
        then old ^. nextL sel
        else Just $ shifter l
    shifter n = if n &lt; k then n else n - 1
    go vs = generate (V.length vs - 1) $ \n -&gt;
      vs V.! (if n &lt; k then n else n + 1) &amp; shiftDir Column &amp; shiftDir Row

clearDir :: Direction -&gt; Int -&gt; Matrix a -&gt; Matrix a
clearDir dir i mat = foldl (flip clearAt) mat $ sort $ mapMaybe (fmap fst) $ V.toList $ igetDir dir i mat

clearRow :: Int -&gt; Matrix a -&gt; Matrix a
clearRow = clearDir Row

clearCol :: Int -&gt; Matrix a -&gt; Matrix a
clearCol = clearDir Column

scaleRow :: (DecidableZero a, Multiplicative a) =&gt; a -&gt; Int -&gt; Matrix a -&gt; Matrix a
scaleRow = scaleDir Row

scaleCol :: (DecidableZero a, Multiplicative a) =&gt; a -&gt; Int -&gt; Matrix a -&gt; Matrix a
scaleCol = scaleDir Column

mapDir :: (a -&gt; a) -&gt; Direction
       -&gt; Int -&gt; Matrix a -&gt; Matrix a
mapDir f dir i mat = traverseDir mat trv dir i mat
  where
    trv m k _ = m &amp; coefficients . ix k . value %~ f

traverseDir :: b -&gt; (b -&gt; Int -&gt; Entry a -&gt; b)
               -&gt; Direction
               -&gt; Int -&gt; Matrix a -&gt; b
traverseDir ini f dir i mat =
  runIdentity $  traverseDirM ini (\b j e -&gt; return $ f b j e) dir i mat

traverseDirM :: Monad m =&gt; b -&gt; (b -&gt; Int -&gt; Entry a -&gt; m b)
                -&gt; Direction
                -&gt; Int -&gt; Matrix a -&gt; m b
traverseDirM ini f dir i mat = go (IM.lookup i (mat^.startL dir)) ini
  where
    vec = mat ^. coefficients
    go Nothing  b = return b
    go (Just k) b = do
      let !cur = vec V.! k
      go (cur ^. nextL dir) =&lt;&lt; f b k cur

getDir :: forall a. Monoidal a
       =&gt; Direction -&gt; Int -&gt; Matrix a -&gt; Vector a
getDir dir i mat =
  create $ do
    v &lt;- MV.replicate (mat ^. lenL dir) (zero :: a)
    traverseDirM () (trav v) dir i mat
    return v
  where
    trav :: forall s. MV.MVector s a -&gt; () -&gt; Int -&gt; Entry a -&gt; ST s ()
    trav v _ _ ent = MV.write v (ent ^. nthL dir) (ent ^. value)

igetDir :: forall a. Direction -&gt; Int -&gt; Matrix a -&gt; Vector (Maybe (Int, Entry a))
igetDir dir i mat =
  create $ do
    v &lt;- MV.replicate (mat ^. lenL dir) Nothing
    traverseDirM () (trav v) dir i mat
    return v
  where
    trav :: forall s. MV.MVector s (Maybe (Int, Entry a)) -&gt; () -&gt; Int -&gt; Entry a -&gt; ST s ()
    trav v _ k ent = MV.write v (ent ^. nthL dir) (Just (k, ent))

getRow :: Monoidal a =&gt; Int -&gt; Matrix a -&gt; Vector a
getRow = getDir Row

getCol :: Monoidal a =&gt; Int -&gt; Matrix a -&gt; Vector a
getCol = getDir Column

data Direction = Row | Column deriving (Read, Show, Eq, Ord)

lenL, countL :: Direction -&gt; Lens&#39; (Matrix a) Int
lenL Row = width
lenL Column = height
countL Row = height
countL Column = width

nthL, coordL :: Direction -&gt; Lens&#39; (Entry a) Int
coordL Row = idx . _1
coordL Column = idx . _2

nthL Row = idx . _2
nthL Column = idx . _1

startL :: Direction -&gt; Lens&#39; (Matrix a) (IntMap Int)
startL Row = rowStart
startL Column = colStart

nextL :: Direction -&gt; Lens&#39; (Entry a) (Maybe Int)
nextL Row    = rowNext
nextL Column = colNext

addDir :: forall a. (DecidableZero a)
       =&gt; Direction -&gt; Vector a -&gt; Int -&gt; Matrix a -&gt; Matrix a
addDir dir vec i mat = runST $ do
    mv &lt;- thaw $ mat ^. coefficients
    let n = MV.length mv
        upd (dic, del) k e = do
          let v&#39; = e ^. value + IM.findWithDefault zero (e ^. nthL dir) mp
          d&#39; &lt;- if isZero v&#39;
                then return $ k : del
                else MV.write mv k (e &amp; value .~ v&#39;) &gt;&gt; return del
          return (IM.delete (e ^. nthL dir) dic, d&#39;)
    (rest, dels) &lt;- traverseDirM (mp, []) upd dir i mat
    mv&#39; &lt;- if IM.null rest
           then return mv
           else grow mv (IM.size rest)
    let app j (p, k, opo) v = do
          let preOpo = mat ^. startL (perp dir) . at j
          MV.write mv&#39; k $ newEntry v
                         &amp; nextL dir .~ p
                         &amp; nextL (perp dir) .~ preOpo
                         &amp; coordL dir .~ i
                         &amp; nthL dir .~ j

          return (Just k, k+1, alter (const $ Just k) j opo)
    (l, _, opoStart) &lt;- ifoldlM app (mat ^. startL dir . at i, n, mat ^. startL (perp dir)) rest
    v&#39; &lt;- unsafeFreeze mv&#39;
    let mat&#39; = mat &amp; coefficients .~ v&#39;
                   &amp; startL dir %~ alter (const l) i
                   &amp; startL (perp dir) .~ opoStart
    return $ foldr clearAt mat&#39; dels
  where
    mp :: IntMap a
    mp = V.ifoldr (\k v d -&gt; if isZero v then d else IM.insert k v d) IM.empty vec

perp :: Direction -&gt; Direction
perp Row = Column
perp Column = Row

addRow :: (DecidableZero a) =&gt; Vector a -&gt; Int -&gt; Matrix a -&gt; Matrix a
addRow = addDir Row

addCol :: (DecidableZero a) =&gt; Vector a -&gt; Int -&gt; Matrix a -&gt; Matrix a
addCol = addDir Column

inBound :: (Int, Int) -&gt; Matrix a -&gt; Bool
inBound (i, j) mat = 0 &lt;= i &amp;&amp; i &lt; mat ^. height &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; mat ^. width

index :: Monoidal a =&gt; IM.Key -&gt; Int -&gt; Matrix a -&gt; Maybe a
index i j mat
  | not $ inBound (i, j) mat = Nothing
  | otherwise = Just $ go (IM.lookup i $ mat ^. rowStart)
  where
    go Nothing  = zero
    go (Just k) =
      let e = (mat ^. coefficients) V.! k
      in if e^.idx._2 == j
         then e ^. value
         else go (e^.rowNext)

(!) :: Monoidal a =&gt; Matrix a -&gt; (Int, Int) -&gt; a
(!) a (i, j) = fromJust $ index i j a

combineDir :: (DecidableZero a, Multiplicative a) =&gt; Direction -&gt; a -&gt; Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
combineDir dir alpha i j mat = addDir dir (V.map (alpha *) $ getDir dir i mat) j mat

combineRows :: (DecidableZero a, Multiplicative a) =&gt; a -&gt; Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
combineRows = combineDir Row

combineCols :: (DecidableZero a, Multiplicative a) =&gt; a -&gt; Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
combineCols = combineDir Column

nrows, ncols :: Matrix a -&gt; Int
ncols = view width
nrows = view height

identity :: Unital a =&gt; Int -&gt; Matrix a
identity n =
  let idMap = IM.fromList [(i,i) | i &lt;- [0..n-1]]
  in Matrix (V.fromList [newEntry one &amp; idx .~ (i,i) | i &lt;- [0..n-1]])
            idMap idMap n n

diag :: DecidableZero a =&gt; Vector a -&gt; Matrix a
diag v =
  let n = V.length v
      idMap = IM.fromList [(i,i) | i &lt;- [0..n-1]]
  in clearZero $ Matrix (V.imap (\i a -&gt; newEntry a &amp; idx .~ (i,i)) v)
                 idMap idMap n n

catDir :: DecidableZero b =&gt; Direction -&gt; Matrix b -&gt; Vector b -&gt; Matrix b
catDir dir mat vec = runST $ do
  let seed = V.filter (not . isZero . snd) $ V.take (mat ^. lenL dir) $ V.indexed vec
      n    = V.length $ mat ^. coefficients
      curD = mat ^. countL dir
      getNextIdx l | l == 0 = Nothing
                   | otherwise = Just (n+l-1)
  mv &lt;- flip grow (V.length seed) =&lt;&lt; thaw (mat^.coefficients)
  let upd (k, v) (l, opdic) = do
        MV.write mv (n+l) $ newEntry v
                          &amp; nthL dir .~ k
                          &amp; coordL dir .~ curD
                          &amp; nextL dir .~ getNextIdx l
                          &amp; nextL (perp dir) .~ IM.lookup k opdic
        return (l+1, alter (const $ Just $ n+l) k opdic)
  (l, op&#39;) &lt;- foldlMOf folded (flip upd) (0, mat ^. startL (perp dir)) seed
  v &lt;- unsafeFreeze mv
  return $ mat &amp; countL dir +~ 1
               &amp; startL dir %~ alter (const $ getNextIdx l) curD
               &amp; startL (perp dir) .~ op&#39;
               &amp; coefficients .~ v

dirVector :: DecidableZero a =&gt; Direction -&gt; Vector a -&gt; Matrix a
dirVector Row = rowVector
dirVector Column = colVector

rowVector :: DecidableZero a =&gt; Vector a -&gt; Matrix a
rowVector = fromLists. (:[]) . V.toList

colVector :: DecidableZero a =&gt; Vector a -&gt; Matrix a
colVector = fromLists . map (:[]) . V.toList

toDirs :: Monoidal a =&gt; Direction -&gt; Matrix a -&gt; [Vector a]
toDirs dir mat = [ getDir dir i mat | i &lt;- [0..mat^.countL dir-1]]

toRows :: Monoidal a =&gt; Matrix a -&gt; [Vector a]
toRows = toDirs Row

toCols :: Monoidal a =&gt; Matrix a -&gt; [Vector a]
toCols = toDirs Column

appendDir :: DecidableZero b =&gt; Direction -&gt; Matrix b -&gt; Matrix b -&gt; Matrix b
appendDir dir m = foldl (catDir dir) m . toDirs dir

(&lt;--&gt;) :: DecidableZero b =&gt; Matrix b -&gt; Matrix b -&gt; Matrix b
(&lt;--&gt;) = appendDir Row

(&lt;||&gt;) :: DecidableZero b =&gt; Matrix b -&gt; Matrix b -&gt; Matrix b
(&lt;||&gt;) = appendDir Column

catRow :: DecidableZero b =&gt; Matrix b -&gt; Vector b -&gt; Matrix b
catRow = catDir Row

catCol :: DecidableZero b =&gt; Matrix b -&gt; Vector b -&gt; Matrix b
catCol = catDir Column

switchRows :: Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
switchRows = swapRows

switchCols :: Int -&gt; Int -&gt; Matrix a -&gt; Matrix a
switchCols = swapCols

cmap :: DecidableZero a =&gt; (a1 -&gt; a) -&gt; Matrix a1 -&gt; Matrix a
cmap f = clearZero . (coefficients . mapped . value %~ f)

clearZero :: DecidableZero a =&gt; Matrix a -&gt; Matrix a
clearZero mat = V.ifoldr (\i v m -&gt; if isZero (v^.value) then clearAt i m else m)
                mat (mat ^. coefficients)

transpose :: Matrix a -&gt; Matrix a
transpose mat = mat &amp; rowStart .~ mat^.colStart
                    &amp; colStart .~ mat^.rowStart
                    &amp; height   .~ mat^.width
                    &amp; width    .~ mat^.height
                    &amp; coefficients . each %~ swapEntry
  where
    swapEntry ent = ent &amp; idx     %~ swap
                        &amp; rowNext .~ ent ^. colNext
                        &amp; colNext .~ ent ^. rowNext

zeroMat :: Int -&gt; Int -&gt; Matrix a
zeroMat = Matrix V.empty IM.empty IM.empty

dirCount :: Direction -&gt; Int -&gt; Matrix a -&gt; Int
dirCount = traverseDir 0 (\a _ _ -&gt; succ a)

rowCount :: Int -&gt; Matrix a -&gt; Int
rowCount = dirCount Row

colCount :: Int -&gt; Matrix a -&gt; Int
colCount = dirCount Column

instance (Ord a, Semigroup b) =&gt; Semigroup (MaxEntry a b) where
  MaxEntry a as &lt;&gt; MaxEntry b bs =
    case compare a b of
      EQ -&gt; MaxEntry a (as &lt;&gt; bs)
      LT -&gt; MaxEntry b bs
      GT -&gt; MaxEntry a as

instance (Ord a, Bounded a, Monoid b) =&gt; Monoid (MaxEntry a b) where
  mappend (MaxEntry a as) (MaxEntry b bs) =
    case compare a b of
      EQ -&gt; MaxEntry a (as `mappend` bs)
      LT -&gt; MaxEntry b bs
      GT -&gt; MaxEntry a as
  mempty = MaxEntry minBound mempty


newGaussianState :: Unital a =&gt; Matrix a -&gt; GaussianState a
newGaussianState inp =
  GaussianState inp (identity $ inp ^. height) (-1) (getHeaviest IS.empty inp) 0 one

getHeaviest :: IntSet -&gt; Matrix a -&gt; IntSet
getHeaviest old inp =
  if IS.size old &gt;= inp^.width*5`P.div`100
  then old
  else  let news = entry $ mconcat $ map (\k -&gt; MaxEntry (colCount k inp) (IS.singleton k)) $
                   IS.toList $ IM.keysSet (inp^.colStart) IS.\\ old
        in news `IS.union` old

traverseRow :: b -&gt; (b -&gt; Int -&gt; Entry a -&gt; b) -&gt; Int -&gt; Matrix a -&gt; b
traverseRow a f = traverseDir a f Row

traverseCol :: b -&gt; (b -&gt; Int -&gt; Entry a -&gt; b) -&gt; Int -&gt; Matrix a -&gt; b
traverseCol a f = traverseDir a f Column

structuredGauss :: (DecidableZero a, Division a, Group a)
                =&gt; Matrix a -&gt; (Matrix a, Matrix a)
structuredGauss = structuredGauss&#39; &gt;&gt;&gt; view _1 &amp;&amp;&amp; view _2

structuredGauss&#39; :: (DecidableZero a, Division a, Group a)
                 =&gt; Matrix a -&gt; (Matrix a, Matrix a, a)
structuredGauss&#39; = evalState go . newGaussianState
  where
    countLight heavys = traverseRow (0 :: Int)
                           (\(!c) _ ent -&gt; if (ent^.coordL Column) `IS.member` heavys
                                        then c
                                        else c+1)
    go = do
      old &lt;- use input
      destRow &lt;- use curRow
      pcol &lt;- use prevCol
      (_, rest) &lt;- uses (input.colStart) (IM.split pcol)
      case minViewWithKey rest of
        _ | destRow &gt;= old ^. height -&gt; (,,) &lt;$&gt; use input &lt;*&gt; use output &lt;*&gt; use detAcc
        Nothing -&gt; (,,) &lt;$&gt; use input &lt;*&gt; use output &lt;*&gt; use detAcc
        Just ((pivCol, _), _) -&gt; do
          heavys &lt;- use heavyCols
          prevCol .= pivCol
          let trav b _ ent = do
                if (ent ^. coordL Row) &lt; destRow
                  then do
                  return b
                  else do
                  let lc = countLight heavys (ent ^. coordL Row) old
                  return $ case b of
                    Nothing -&gt; Just (ent, lc)
                    Just (p, l0)
                      | l0 &lt;= lc  -&gt; Just (p, l0)
                      | otherwise -&gt; Just (ent, lc)
          mans &lt;- traverseDirM Nothing trav Column pivCol old
          case mans of
            Nothing -&gt; nextElim
            Just (pivot, _) -&gt; do
              let pivRow = pivot ^. coordL Row
                  pivCoe = pivot ^. value
                  sgn    = if pivRow == destRow then one else negate one
              p0 &lt;- use output
              let elim (m, p) _ ent = do
                    if ent^.coordL Row /= pivRow
                      then do
                        let coe = negate (ent ^. value) / pivCoe
                        return $ (m, p) &amp; both %~ combineRows coe pivRow (ent ^. coordL Row)
                      else do
                        return (m, p)
              (input&#39;, output&#39;) &lt;- traverseDirM (old, p0) elim Column pivCol old
                    &lt;&amp;&gt; both %~ scaleRow (recip pivCoe) destRow . switchRows destRow pivRow
              input .= input&#39;
              output .= output&#39;
              curRow += 1
              detAcc %= (*(pivCoe*sgn))
              nextElim
    nextElim = do
      oldHeavys &lt;- use heavyCols
      newHeavyCols &lt;- uses input (getHeaviest oldHeavys)
      heavyCols %= IS.union newHeavyCols
      go

nonZeroEntries :: Matrix a -&gt; Vector ((Int, Int), a)
nonZeroEntries mat = V.map (view idx &amp;&amp;&amp; view value) $ mat ^. coefficients

matListView :: (Show a, Monoidal a) =&gt; Matrix a -&gt; String
matListView = unlines . map ((&#39;\t&#39;:).show) . toLists

prettyMat :: Show a =&gt; Matrix a -&gt; String
prettyMat mat =
  unlines [ &quot;row start: &quot; &lt;&gt; starter Row
          , &quot;col start: &quot; &lt;&gt; starter Column
          , &quot;[&quot; &lt;&gt; (intercalate &quot;, &quot; $ V.toList $ V.imap (\i e -&gt; &quot;(#&quot; &lt;&gt; show i &lt;&gt; &quot;) &quot; &lt;&gt; prettyEntry e) $ mat^.coefficients) &lt;&gt; &quot;]&quot;
          ]
  where
    starter dir = intercalate &quot;, &quot; (map (\(a,b) -&gt; show a ++ &quot; -&gt; &quot; ++ show b) (mat^.startL dir.to IM.toList))

prettyEntry :: Show a =&gt; Entry a -&gt; String
prettyEntry ent =
  concat [ show $ ent^.value, &quot; &quot;
         , show $ ent^.idx
         , &quot;-&gt;(&quot;
         ,showMaybe (ent^.nextL Row)
         , &quot;, &quot;
         ,showMaybe (ent^.nextL Column)
         , &quot;)&quot;
         ]
  where
    showMaybe = maybe &quot;_&quot; show

multWithVector :: (Multiplicative a, Monoidal a)
               =&gt; Matrix a -&gt; Vector a -&gt; Vector a
multWithVector mat v =
  V.generate (mat^.height) $ \i -&gt;
  traverseRow zero (\acc _ ent -&gt; acc + (ent^.value)*(v V.! (ent^.nthL Row))) i mat

nonZeroDirs :: Direction -&gt; Matrix r -&gt; [Int]
nonZeroDirs dir = view $ startL dir . to IM.keys

nonZeroRows :: Matrix r -&gt; [Int]
nonZeroRows = nonZeroDirs Row

nonZeroCols :: Matrix r -&gt; [Int]
nonZeroCols = nonZeroDirs Column

testCase :: Matrix (Fraction Integer)
testCase = fromLists [[0,0,0,0,0,0,2,-3,-1,0]
                      ,[0,0,0,2,-3,-1,0,0,0,0]
                      ,[0,2,-3,0,-1,0,0,0,0,0]
                      ,[1,0,1,0,0,1,-2,0,0,0]
                      ,[2,-3,0,-1,0,0,0,0,0,0]
                      ,[1,0,1,0,0,1,0,0,0,-1]
                      ,[1,0,1,0,0,1,-2,0,0,0]]

newtype Square n r = Square { runSquare :: Matrix r
                            } deriving (Show, Eq, Additive, Multiplicative)

deriving instance (DecidableZero r, Semiring r, Multiplicative r)
               =&gt; LeftModule (Scalar r) (Square n r)
deriving instance (DecidableZero r, Semiring r, Multiplicative r)
               =&gt; RightModule (Scalar r) (Square n r)

instance (Unital r, Multiplicative r, Reifies n Integer, DecidableZero r) =&gt; Unital (Square n r) where
  one = Square $ identity $ fromInteger $ reflect (Proxy :: Proxy n)

instance (DecidableZero r, Multiplicative r) =&gt; Multiplicative (Matrix r) where
  m * n = fromList [ ((i,j),sum $ V.zipWith (*) (getRow i m) (getCol j n))
                   | i &lt;- nonZeroRows m
                   , j &lt;- nonZeroCols n
                   ] &amp; width .~ n^.width
                     &amp; height .~ m^.height


instance (DecidableZero r, RightModule Natural r) =&gt; RightModule Natural (Matrix r) where
  m *. n = cmap (*. n) m

instance (DecidableZero r, LeftModule Natural r) =&gt; LeftModule Natural (Matrix r) where
  n .* m = cmap (n .*) m

instance (DecidableZero r, RightModule Integer r) =&gt; RightModule Integer (Matrix r) where
  m *. n = cmap (*. n) m

instance (DecidableZero r, LeftModule Integer r) =&gt; LeftModule Integer (Matrix r) where
  n .* m = cmap (n .*) m

instance (DecidableZero r)
      =&gt; Monoidal (Matrix r) where
  zero = zeroMat 0 0

instance (DecidableZero r) =&gt; Additive (Matrix r) where
  m + n =
    let dir = minimumBy (comparing $ length . flip nonZeroDirs n)
              [Row, Column]
    in foldr (\i l -&gt; addDir dir (getDir dir i n) i l) m (nonZeroDirs dir n)

instance (DecidableZero r, Semiring r, Multiplicative r)
      =&gt; LeftModule (Scalar r) (Matrix r) where
  Scalar r .* mat = cmap (r*) mat

instance (DecidableZero r, Semiring r, Multiplicative r)
      =&gt; RightModule (Scalar r) (Matrix r) where
  mat *. Scalar r = cmap (*r) mat

instance (DecidableZero r, Group r) =&gt; Group (Matrix r) where
  negate = cmap negate

instance (DecidableZero r, Abelian r) =&gt; Abelian (Matrix r)

instance (DecidableZero r, Semiring r) =&gt; Semiring (Matrix r)

substMatrix :: (CoeffRing r)
            =&gt; Matrix r -&gt; Polynomial r 1 -&gt; Matrix r
substMatrix m f =
  let n = ncols m
  in if n == nrows m
     then reify (P.toInteger n) $ \pxy -&gt; runSquare $ substUnivariate (toSquare pxy m) f
     else error &quot;Matrix must be square&quot;

toSquare :: proxy n -&gt; Matrix r -&gt; Square n r
toSquare _ = Square

(&lt;.&gt;) :: (Multiplicative m, Monoidal m) =&gt; Vector m -&gt; Vector m -&gt; m
v &lt;.&gt; u = sum $ V.zipWith (*) v u

krylovMinpol :: (Eq a, Ring a, DecidableZero a, DecidableUnits a,
                 Field a, ZeroProductSemiring a,
                 Random a, MonadRandom m)
             =&gt; Matrix a -&gt; Vector a -&gt; m (Polynomial a 1)
krylovMinpol m b
  | V.all isZero b = return one
  | otherwise = reify (P.toInteger n) $ \pxy -&gt; do
    iterateUntil (\h -&gt; V.all isZero $ multWithVector (substMatrix m h) b) $ do
      u &lt;- replicateM n getRandom
      return $ minpolRecurrent (fromIntegral n)
        [ V.fromList u &lt;.&gt; multWithVector (runSquare $ toSquare pxy m ^ fromIntegral i) b
        | i &lt;- [0..2*n-1]]
    where
      n = ncols m

-- | Solving linear equation using linearly recurrent sequence (Wiedemann algorithm).
solveWiedemann :: (Eq a, Field a, DecidableZero a, DecidableUnits a,
                ZeroProductSemiring a, Random a, MonadRandom m)
            =&gt; Matrix a -&gt; Vector a -&gt; m (Either (Vector a) (Vector a))
solveWiedemann a b = do
  m &lt;- krylovMinpol a b
  return $
    let m0 = injectCoeff (coeff one m)
        g = (m - m0) `quot` varX
    in if isZero (coeff one m)
       then Left $ substMatrix a g `multWithVector` b
       else let h = negate g `quot` m0
            in Right $ substMatrix a h `multWithVector` b

rankLM :: (DecidableZero r, Division r, Group r) =&gt; Matrix r -&gt; Int
rankLM mat =
  let m&#39; = fst $ structuredGauss mat
  in min (length $ nonZeroRows m&#39;) (length $ nonZeroCols m&#39;)

splitIndependentDirs :: (DecidableZero a, Field a)
                     =&gt; Direction -&gt; Matrix a
                     -&gt; (Matrix a, [Int], [Int])
                     -- ^ @(m&#39;, bs, as)@ with @m@ is full-rank submatrix,
                     --   @bs@ are independent and @as@ are dependent.
splitIndependentDirs dir mat =
  case nonZeroDirs dir mat of
    []  -&gt; (zero, [], [])
    [a] -&gt; (dirVector dir $ getDir dir a mat, [a], [])
    (x:xs)  -&gt; go 1 xs (dirVector dir $ getDir dir x mat) [x] []
  where
    n = min (nrows mat) (ncols mat)
    go _ []     nat ok bad = (nat, ok, bad)
    go i (k:ks) nat ok bad
      | i &gt;= n = (nat, ok, bad)
      | otherwise =
        let nat&#39; = catDir dir nat $ getDir dir k mat
        in if ({-# SCC &quot;rankLM&quot; #-} rankLM nat&#39;) == i
           then go i     ks nat  ok     (k:bad)
           else go (i+1) ks nat&#39; (k:ok) bad

intDet :: Matrix Integer -&gt; Integer
intDet mat =
  let b = V.maximum $ V.map (P.fromInteger . abs . snd) $ nonZeroEntries mat
      n = fromIntegral $ ncols mat
      c = n^(n `P.div` 2) * b^n
      r = ceilingLogBase2 (2*fromIntegral c + 1)
      ps = take r primes
      m  = product ps
      d  = chineseRemainder [ (p,
                               reifyPrimeField p $ \pxy -&gt;
                               shiftHalf p $ naturalRepr $ view _3 $
                               structuredGauss&#39; (cmap (modNat&#39; pxy) mat))
                            | p &lt;- ps]
      off = d `div` m
  in if d == 0
     then 0
     else minimumBy (comparing abs) [d - m * off, d - m * (off + 1)]

shiftHalf :: P.Integral a =&gt; a -&gt; a -&gt; a
shiftHalf p n =
  let s = p `P.div` 2
  in (n P.+ s) `P.mod` p P.- s

triangulateModular :: Matrix (Fraction Integer)
                   -&gt; (Matrix (Fraction Integer),
                       Matrix (Fraction Integer))
triangulateModular mat0 =
  let ps = filter ((/= 0) . (P.mod l)) primes
  in go ps
  where
    ds = V.foldr (lcm&#39; . abs . denominator.snd) 1 $ nonZeroEntries mat0
    mN = V.foldr (lcm&#39; . abs . numerator . snd) 1 $ nonZeroEntries mat0
    l  = lcm&#39; ds mN
    go (p:ps) =
      let (indepRows, _, indepCols, depCols) = reifyPrimeField p $ \pxy -&gt;
            let mat = cmap (modRat pxy) mat0
                (koho, IS.fromList -&gt; irs, IS.fromList -&gt; drs) =
                  {-# SCC &quot;splitRow&quot; #-} splitIndependentDirs Row mat
                (_, IS.fromList -&gt; ics, IS.fromList -&gt; dcs) =
                  {-# SCC &quot;splitCol&quot; #-} splitIndependentDirs Column koho
            in (irs,
                drs `IS.union` (IS.fromList (nonZeroRows mat0) IS.\\ irs),
                ics,
                dcs `IS.union` (IS.fromList (nonZeroCols $ extract irdic colIdentDic) IS.\\ ics))
          colIdentDic = IM.fromList $ zip [0..ncols mat0 - 1] [0..]
          irdic = IM.fromList $ zip (IS.toAscList indepRows) [0..]
          icdic = IM.fromList $ zip (IS.toAscList indepCols) [0..]
          dcdic = IM.fromList $ zip (IS.toDescList depCols) [0..]
          newIdx rd cd (i, j) = (,) &lt;$&gt; IM.lookup i rd &lt;*&gt; IM.lookup j cd
          extract rd cd = fromList (mapMaybe (\(ind, c) -&gt; (,c) &lt;$&gt; newIdx rd cd ind) $
                          V.toList $ nonZeroEntries mat0)
                          &amp; height .~ IM.size rd
                          &amp; width  .~ IM.size cd
          spec = extract irdic icdic
          qs = filter (\r -&gt; ds `mod` r /= 0 &amp;&amp; ({-# SCC &quot;checkDet&quot; #-} reifyPrimeField r $ \pxy -&gt;
                          not $ isZero $ view _3 $
                          structuredGauss&#39; $ cmap (modRat pxy) $ spec)) primes
          anss = parMap rdeepseq (\xs -&gt; fromJust $ ala First foldMap $
                                         map (\q -&gt; solveHensel 10 q spec xs) qs) $
                 toCols $ extract irdic dcdic
          permMat = build [] (ncols mat0 - 1)
                    (zip (IS.toDescList indepCols) $ reverse $ toCols $ identity $ nrows spec) $
                    zip (IS.toDescList depCols) anss
          origDeled = extract irdic colIdentDic &amp; width .~ mat0^.width
     in if (spec * permMat) == origDeled
        then (permMat, spec)
        else go ps
    go _ = error &quot;Cannot happen!&quot;
    build ans i mns vecs
      | i &lt; 0 = fromCols ans
      | otherwise = {-# SCC &quot;building&quot; #-}
        case vecs of
          ((k, v) : vs) | i == k -&gt; build (v : ans) (i-1) mns vs
          _ -&gt;
            case mns of
              ((l,m):mn) | i == l -&gt; build (m : ans) (i-1) mn vecs
              _ -&gt; build (V.empty : ans) (i-1) mns vecs

(.!) :: (a -&gt; b) -&gt; (t -&gt; a) -&gt; t -&gt; b
(f .! g) x = f $! g x

infixr 9 .!

-- trMat lab mat = DT.trace (lab &lt;&gt; &quot;: &quot; &lt;&gt; show (toLists mat)) mat

clearDenom :: Euclidean a =&gt; Matrix (Fraction a) -&gt; (a, Matrix a)
clearDenom mat =
  let g = V.foldr&#39; (lcm&#39; . denominator . snd) one $ nonZeroEntries mat
  in (g, cmap (numerator . (* (g % one))) mat)

lcm&#39; :: Euclidean r =&gt; r -&gt; r -&gt; r
lcm&#39; n m = n * m `quot` gcd n m

henselLift :: Integer           -- ^ prime number @p@
           -&gt; Matrix Integer -- ^ original matrix @M@
           -&gt; Matrix Integer -- ^ inverse matrix of @M@ mod @p@
           -&gt; V.Vector Integer  -- ^ coefficient vector @v@
           -&gt; [V.Vector Integer]  -- ^ vector @x@ with @Mx = b mod p@
henselLift p m q b =
  map (view _2) $ iterate step (1, V.replicate (V.length b) 0, b)
  where
    step (s, acc, r)
      | otherwise =
        let u = reifyPrimeField p $ \pxy -&gt;
              V.map (naturalRepr . modNat&#39; pxy) $ q `multWithVector` r
            r&#39; = V.map (`quot` p) $ V.zipWith (-) r (m `multWithVector` u)
        in (s*p, acc + V.map (s*) u, r&#39;)


solveHensel :: Int -&gt; Integer
            -&gt; Matrix (Fraction Integer)
            -&gt; Vector (Fraction Integer)
            -&gt; Maybe (Vector (Fraction Integer))
solveHensel cyc p mat b = {-# SCC &quot;solveHensel&quot; #-}
  let g0 = V.foldr (lcm . denominator . view _2) one $ nonZeroEntries mat
      g1 = V.foldr (lcm . denominator) one b
      g  = lcm g0 g1 % 1
      mat&#39; = cmap (numerator . (*g)) mat
      b&#39;   = V.map (numerator . (*g)) b
      q = reifyPrimeField p $ \pxy -&gt;
        cmap naturalRepr $ snd $ structuredGauss $ cmap (modNat&#39; pxy) mat&#39;
      hls = henselLift p mat&#39; q b&#39;
  in go Nothing $ drop cyc $ zip [p^i | i &lt;- [0..]] hls
  where
    go _ [] = Nothing
    go prev ((q,x):xs) =
      let mans = V.mapM (recoverRat (P.floor $ P.sqrt (fromIntegral q P./ 2 :: Double)) q) x
      in case mans of
        Just x&#39; | mat `multWithVector` x&#39; == b -&gt; Just x&#39;
                | mans == prev -&gt; Nothing
        _ -&gt; go mans (drop cyc xs)

killerMat :: Matrix (Fraction Integer)
killerMat = fromLists [[1,9 / 5,-9 / 10],[1,0,0]]

-- tr str a = DT.trace (str &lt;&gt; &quot;: &quot; &lt;&gt;show a) a
</span> </pre></body></html></DOCTYPE>
<DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;=""><html xmlns="http://www.w3.org/1999/xhtml"><head><link href="style.css" type="text/css" rel="stylesheet"></link><script src="highlight.js" type="text/javascript"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE ConstraintKinds, DataKinds, ExistentialQuantification        #-}</span> <span></span> <a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE ExplicitNamespaces, FlexibleContexts, FlexibleInstances      #-}</span> <span></span> <a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE GADTs, GeneralizedNewtypeDeriving, IncoherentInstances       #-}</span> <span></span> <a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE LiberalTypeSynonyms, MultiParamTypeClasses, ParallelListComp #-}</span> <span></span> <a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE PatternSynonyms, PolyKinds, RankNTypes, ScopedTypeVariables  #-}</span> <span></span> <a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving, TemplateHaskell, TypeApplications        #-}</span> <span></span> <a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilies, TypeOperators, UndecidableInstances            #-}</span> <span></span> <a name="line-8"></a><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-orphans #-}</span> <span></span> <a name="line-9"></a><span class="hs-keyword">module</span> <span></span> <span class="hs-identifier">Algebra</span> <span class="hs-operator">.</span> <span class="hs-identifier">Ring</span> <span class="hs-operator">.</span> <span class="hs-identifier">Polynomial</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monomial</span> <span></span> <a name="line-10"></a><span></span> <span class="hs-special">(</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#Monomial"><span class="hs-identifier hs-type">Monomial</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#OrderedMonomial"><span class="hs-identifier hs-type">OrderedMonomial</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a name="line-11"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#IsOrder"><span class="hs-identifier hs-type">IsOrder</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#IsMonomialOrder"><span class="hs-identifier hs-type">IsMonomialOrder</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#MonomialOrder"><span class="hs-identifier hs-type">MonomialOrder</span> </a><span class="hs-special">,</span> <span></span> <a name="line-12"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#IsStrongMonomialOrder"><span class="hs-identifier hs-type">IsStrongMonomialOrder</span> </a><span class="hs-special">,</span> <span></span> <a name="line-13"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#isRelativelyPrime"><span class="hs-identifier hs-var">isRelativelyPrime</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#totalDegree"><span class="hs-identifier hs-var">totalDegree</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#ProductOrder"><span class="hs-identifier hs-type">ProductOrder</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a name="line-14"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#productOrder"><span class="hs-identifier hs-var">productOrder</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#productOrder%27"><span class="hs-identifier hs-var">productOrder&#39;</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#WeightProxy"><span class="hs-identifier hs-type">WeightProxy</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#WeightOrder"><span class="hs-identifier hs-type">WeightOrder</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a name="line-15"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#gcdMonomial"><span class="hs-identifier hs-var">gcdMonomial</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#divs"><span class="hs-identifier hs-var">divs</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#isPowerOf"><span class="hs-identifier hs-var">isPowerOf</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#tryDiv"><span class="hs-identifier hs-var">tryDiv</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#lcmMonomial"><span class="hs-identifier hs-var">lcmMonomial</span> </a><span class="hs-special">,</span> <span></span> <a name="line-16"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#Lex"><span class="hs-identifier hs-type">Lex</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#EliminationType"><span class="hs-identifier hs-type">EliminationType</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#EliminationOrder"><span class="hs-identifier hs-type">EliminationOrder</span> </a><span class="hs-special">,</span> <span></span> <a name="line-17"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#WeightedEliminationOrder"><span class="hs-identifier hs-type">WeightedEliminationOrder</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#eliminationOrder"><span class="hs-identifier hs-var">eliminationOrder</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#weightedEliminationOrder"><span class="hs-identifier hs-var">weightedEliminationOrder</span> </a><span class="hs-special">,</span> <span></span> <a name="line-18"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#lex"><span class="hs-identifier hs-var">lex</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#revlex"><span class="hs-identifier hs-var">revlex</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#graded"><span class="hs-identifier hs-var">graded</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#grlex"><span class="hs-identifier hs-var">grlex</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#grevlex"><span class="hs-identifier hs-var">grevlex</span> </a><span class="hs-special">,</span> <span></span> <a name="line-19"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#weightOrder"><span class="hs-identifier hs-var">weightOrder</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#Grevlex"><span class="hs-identifier hs-type">Grevlex</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#fromList"><span class="hs-identifier hs-var">fromList</span> </a><span class="hs-special">,</span> <span></span> <a name="line-20"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#Revlex"><span class="hs-identifier hs-type">Revlex</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#Grlex"><span class="hs-identifier hs-type">Grlex</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#Graded"><span class="hs-identifier hs-type">Graded</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a name="line-21"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#castMonomial"><span class="hs-identifier hs-var">castMonomial</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#scastMonomial"><span class="hs-identifier hs-var">scastMonomial</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#varMonom"><span class="hs-identifier hs-var">varMonom</span> </a><span class="hs-special">,</span> <span></span> <a name="line-22"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#changeMonomialOrder"><span class="hs-identifier hs-var">changeMonomialOrder</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#changeMonomialOrderProxy"><span class="hs-identifier hs-var">changeMonomialOrderProxy</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#sOnes"><span class="hs-identifier hs-var">sOnes</span> </a><span class="hs-special">,</span> <span></span> <a name="line-23"></a><span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#withStrongMonomialOrder"><span class="hs-identifier hs-var">withStrongMonomialOrder</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#cmpAnyMonomial"><span class="hs-identifier hs-var">cmpAnyMonomial</span> </a><span class="hs-special">,</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#orderMonomial"><span class="hs-identifier hs-var">orderMonomial</span> </a><span></span> <a name="line-24"></a><span></span> <span class="hs-special">)</span> <span></span> <span class="hs-keyword">where</span> <span></span> <a name="line-25"></a><span class="hs-keyword">import</span> <span></span> <a href="Algebra.Internal.html"><span class="hs-identifier">Algebra</span> <span class="hs-operator">.</span> <span class="hs-identifier">Internal</span> </a><span></span> <a name="line-26"></a><span></span> <a name="line-27"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">AlgebraicPrelude</span> <span></span> <span class="hs-keyword">hiding</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">lex</span> <span class="hs-special">)</span> <span></span> <a name="line-28"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">DeepSeq</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">NFData</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-29"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Lens</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Ixed</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">alaf</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">imap</span> <span class="hs-special">,</span> <span></span> <a name="line-30"></a><span></span> <span class="hs-identifier hs-var">makeLenses</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">makeWrapped</span> <span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <span class="hs-operator hs-var">%~</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a name="line-31"></a><span></span> <span class="hs-special">(</span> <span class="hs-operator hs-var">&amp;</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <span class="hs-operator hs-var">.~</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">_Wrapped</span> <span class="hs-special">)</span> <span></span> <a name="line-32"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Constraint</span> <span></span> <span class="hs-special">(</span> <span class="hs-special">(</span> <span class="hs-operator hs-type">:=&gt;</span> <span class="hs-special">)</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Dict</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-33"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Constraint</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">C</span> <span></span> <a name="line-34"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Constraint</span> <span class="hs-operator">.</span> <span class="hs-identifier">Forall</span> <span></span> <a name="line-35"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Foldable</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">F</span> <span></span> <a name="line-36"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Hashable</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Hashable</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-37"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Kind</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Type</span> <span class="hs-special">)</span> <span></span> <a name="line-38"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Maybe</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">catMaybes</span> <span class="hs-special">)</span> <span></span> <a name="line-39"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monoid</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Dual</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-40"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monoid</span> <span></span> <span class="hs-special">(</span> <span class="hs-special">(</span> <span class="hs-operator hs-var">&lt;&gt;</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-41"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">MonoTraversable</span> <span class="hs-operator">.</span> <span class="hs-identifier">Unprefixed</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">MT</span> <span></span> <a name="line-42"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Ord</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">comparing</span> <span class="hs-special">)</span> <span></span> <a name="line-43"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Singletons</span> <span class="hs-operator">.</span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">POrd</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">SList</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Sing</span> <span></span> <span class="hs-special">(</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-44"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Singletons</span> <span class="hs-operator">.</span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">SingKind</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-45"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Singletons</span> <span class="hs-operator">.</span> <span class="hs-identifier">Prelude</span> <span class="hs-operator">.</span> <span class="hs-identifier">List</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Length</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Replicate</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">sReplicate</span> <span class="hs-special">)</span> <span></span> <a name="line-46"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Singletons</span> <span class="hs-operator">.</span> <span class="hs-identifier">TypeLits</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">withKnownNat</span> <span class="hs-special">)</span> <span></span> <a name="line-47"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Sized</span> <span class="hs-operator">.</span> <span class="hs-identifier">Builtin</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">V</span> <span></span> <a name="line-48"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Type</span> <span class="hs-operator">.</span> <span class="hs-identifier">Natural</span> <span class="hs-operator">.</span> <span class="hs-identifier">Class</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">IsPeano</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">PeanoOrder</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-49"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Type</span> <span class="hs-operator">.</span> <span class="hs-identifier">Ordinal</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Ordinal</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">ordToInt</span> <span class="hs-special">)</span> <span></span> <a name="line-50"></a><span class="hs-comment">-- import           Prelude                         hiding (Fractional (..),</span> <span></span> <a name="line-51"></a><span class="hs-comment">--                                                   Integral (..), Num (..),</span> <span></span> <a name="line-52"></a><span class="hs-comment">--                                                   Real (..), lex, product, sum)</span> <span></span> <a name="line-53"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">P</span> <span></span> <a name="line-54"></a><span></span> <a name="line-55"></a><span class="hs-comment">-- | N-ary Monomial. IntMap contains degrees for each x_i- type Monomial (n :: Nat) = Sized n Int</span> <span></span> <a name="line-56"></a><span class="hs-keyword">type</span> <span></span> <a name="Monomial"><a href="Algebra.Ring.Polynomial.Monomial.html#Monomial"><span class="hs-identifier">Monomial</span> </a></a><span></span> <a name="local-1627860664"><a href="#local-1627860664"><span class="hs-identifier">n</span> </a></a><span></span> <span class="hs-glyph">=</span> <span></span> <a href="Algebra.Internal.html#Sized%27"><span class="hs-identifier hs-type">Sized&#39;</span> </a><span></span> <a href="#local-1627860664"><span class="hs-identifier hs-type">n</span> </a><span></span> <span class="hs-identifier hs-type">Int</span> <span></span> <a name="line-57"></a><span></span> <a name="line-58"></a><span class="hs-comment">-- | A wrapper for monomials with a certain (monomial) order.</span> <span></span> <a name="line-59"></a><span class="hs-keyword">newtype</span> <span></span> <a name="OrderedMonomial"><a href="Algebra.Ring.Polynomial.Monomial.html#OrderedMonomial"><span class="hs-identifier">OrderedMonomial</span> </a></a><span></span> <a name="local-1627860662"><a href="#local-1627860662"><span class="hs-identifier">ordering</span> </a></a><span></span> <a name="local-1627860663"><a href="#local-1627860663"><span class="hs-identifier">n</span> </a></a><span></span> <span class="hs-glyph">=</span> <span></span> <a name="line-60"></a><span></span> <a name="OrderedMonomial"><a href="Algebra.Ring.Polynomial.Monomial.html#OrderedMonomial"><span class="hs-identifier">OrderedMonomial</span> </a></a><span></span> <span class="hs-special">{</span> <span></span> <a name="getMonomial"><a href="Algebra.Ring.Polynomial.Monomial.html#getMonomial"><span class="hs-identifier">getMonomial</span> </a></a><span></span> <span class="hs-glyph">::</span> <span></span> <a href="Algebra.Ring.Polynomial.Monomial.html#Monomial"><span class="hs-identifier hs-type">Monomial</span> </a><span></span> <a href="#local-1627860663"><span class="hs-identifier hs-type">n</span> </a><span></span> <span class="hs-special">}</span> <span></span> <a name="line-61"></a><span></span> <span class="hs-keyword">deriving</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">NFData</span> <span class="hs-special">)</span> <span></span> <a name="line-62"></a><span></span> <a name="line-63"></a><span class="hs-identifier">makeLenses</span> <span></span> <span class="hs-char">&#39;&#39;OrderedMonomial
makeWrapped &#39;&#39;OrderedMonomial

-- | convert NAry list into Monomial.
fromList :: SNat n -&gt; [Int] -&gt; Monomial n
fromList len = V.fromListWithDefault len 0

-- | Monomial order (of degree n). This should satisfy following laws:
-- (1) Totality: forall a, b (a &lt; b || a == b || b &lt; a)
-- (2) Additivity: a &lt;= b ==&gt; a + c &lt;= b + c
-- (3) Non-negative: forall a, 0 &lt;= a
type MonomialOrder n = Monomial n -&gt; Monomial n -&gt; Ordering

isRelativelyPrime :: OrderedMonomial ord n -&gt; OrderedMonomial ord n -&gt; Bool
isRelativelyPrime n m = lcmMonomial n m == n * m

totalDegree :: OrderedMonomial ord n -&gt; Int
totalDegree = P.sum . getMonomial
{-# INLINE totalDegree #-}

-- | Lexicographical order. This *is* a monomial order.
lex :: MonomialOrder n
lex m n = P.foldMap (uncurry compare) $ V.zipSame m n
{-# INLINE [2] lex #-}

-- | Reversed lexicographical order. This is *not* a monomial order.
revlex :: MonomialOrder n
revlex xs ys = foldl (flip (&lt;&gt;)) EQ $ V.zipWithSame (flip compare) xs ys
{-# INLINE [2] revlex #-}

-- | Convert ordering into graded one.
graded :: MonomialOrder n -&gt; MonomialOrder n
graded cmp xs ys = comparing F.sum xs ys &lt;&gt; cmp xs ys
{-# INLINE[2] graded #-}
{-# RULES
&quot;graded/graded&quot;  [~1] forall x. graded (graded x) = graded x
  #-}

-- | Graded lexicographical order. This *is* a monomial order.
grlex :: MonomialOrder n
grlex = graded lex
{-# INLINE [2] grlex #-}

-- | Graded reversed lexicographical order. This *is* a monomial order.
grevlex :: MonomialOrder n
grevlex = graded revlex
{-# INLINE [2] grevlex #-}

deriving instance Hashable (Monomial n) =&gt; Hashable (OrderedMonomial ordering n)
deriving instance (Eq (Monomial n)) =&gt; Eq (OrderedMonomial ordering n)
instance KnownNat n =&gt; Show (OrderedMonomial ord n) where
  show xs =
    let vs = catMaybes $ V.toList $
            imap (\n i -&gt;
                   if i &gt; 0
                   then Just (&quot;X_&quot; ++ show (ordToInt n) ++ if i == 1 then &quot;&quot; else &quot;^&quot; ++ show i)
                   else Nothing)
            $ getMonomial xs
    in if null vs then &quot;1&quot; else unwords vs

instance Multiplicative (OrderedMonomial ord n) where
  OrderedMonomial n * OrderedMonomial m = OrderedMonomial $ V.zipWithSame (+) n m

instance KnownNat n =&gt; Division (OrderedMonomial ord n) where
  recip = _Wrapped %~ V.map P.negate
  OrderedMonomial n / OrderedMonomial m = OrderedMonomial $ V.zipWithSame (-) n m

instance KnownNat n =&gt; Unital (OrderedMonomial ord n) where
  one = OrderedMonomial $ fromList sing []

-- | Class to lookup ordering from its (type-level) name.
class IsOrder (n :: Nat) (ordering :: *) where
  cmpMonomial :: Proxy ordering -&gt; MonomialOrder n

head&#39; :: (0 :&lt; n) ~ &#39;True =&gt; Sized&#39; n a -&gt; a
head&#39; = V.head
{-# INLINE head&#39; #-}

-- We know that Monomial ordering coincides on lex ordering
-- on univariate monomials.
{-# RULES
&quot;cmpMonomial/unary&quot; [~1]
              forall (pxy :: IsMonomialOrder 1 (o :: *) =&gt; Proxy o)
                     (xs :: Sized&#39; 1 Int)
                     (ys :: Sized&#39; 1 Int).
  cmpMonomial pxy xs ys = comparing head&#39; xs ys
 #-}

-- * Names for orderings.
--   We didn&#39;t choose to define one single type for ordering names for the extensibility.
-- | Lexicographical order
data Lex = Lex
           deriving (Show, Eq, Ord)

-- | Reversed lexicographical order
data Revlex = Revlex
              deriving (Show, Eq, Ord)

-- | Graded reversed lexicographical order. Same as @Graded Revlex@.
data Grevlex = Grevlex
               deriving (Show, Eq, Ord)

-- | Graded lexicographical order. Same as @Graded Lex@.
data Grlex = Grlex
             deriving (Show, Eq, Ord)

-- | Graded order from another monomial order.
data Graded ord = Graded ord
                  deriving (Read, Show, Eq, Ord)

instance IsOrder n ord =&gt; IsOrder n (Graded ord) where
  cmpMonomial Proxy = graded (cmpMonomial (Proxy :: Proxy ord))
  {-# INLINE [1] cmpMonomial #-}

instance IsMonomialOrder n ord =&gt; IsMonomialOrder n (Graded ord)

data ProductOrder (n :: Nat) (m :: Nat) (a :: *) (b :: *) where
  ProductOrder :: Sing n -&gt; Sing m -&gt; ord -&gt; ord&#39; -&gt; ProductOrder n m ord ord&#39;

productOrder :: forall ord ord&#39; n m. (IsOrder n ord, IsOrder m ord&#39;, KnownNat n, KnownNat m)
             =&gt; Proxy (ProductOrder n m ord ord&#39;) -&gt; MonomialOrder (n + m)
productOrder _ mon mon&#39; =
  let n = sing :: SNat n
      m = sing :: SNat m
  in withWitness (plusLeqL n m) $
     case (V.splitAt n mon, V.splitAt n mon&#39;) of
      ((xs, xs&#39;), (ys, ys&#39;)) -&gt;
        cmpMonomial (Proxy :: Proxy ord) xs ys &lt;&gt;
        cmpMonomial (Proxy :: Proxy ord&#39;)
          (coerceLength (plusMinus&#39; n m) xs&#39;)
          (coerceLength (plusMinus&#39; n m) ys&#39;)

productOrder&#39; :: forall n ord ord&#39; m.(IsOrder n ord, IsOrder m ord&#39;)
              =&gt; SNat n -&gt; SNat m -&gt; ord -&gt; ord&#39; -&gt; MonomialOrder (n + m)
productOrder&#39; n m _ _ =
  withKnownNat n $ withKnownNat m $
  productOrder (Proxy :: Proxy (ProductOrder n m ord ord&#39;))

type WeightProxy (v :: [Nat]) = SList v

data WeightOrder (v :: [Nat]) (ord :: Type) where
  WeightOrder :: SList (v :: [Nat]) -&gt; Proxy ord -&gt; WeightOrder v ord

calcOrderWeight :: forall vs n. (SingI vs, KnownNat n)
                 =&gt; Proxy (vs :: [Nat]) -&gt; Monomial n -&gt; Int
calcOrderWeight Proxy = calcOrderWeight&#39; (sing :: SList vs)
{-# INLINE calcOrderWeight #-}

calcOrderWeight&#39; :: forall vs n. KnownNat n =&gt; SList (vs :: [Nat]) -&gt; Monomial n -&gt; Int
calcOrderWeight&#39; slst m =
  let cfs = V.fromListWithDefault&#39; (0 :: Int) $ map P.fromIntegral $ fromSing slst
  in P.sum $ V.zipWithSame (*) cfs m
{-# INLINE [2] calcOrderWeight&#39; #-}

weightOrder :: forall n ns ord. (KnownNat n, IsOrder n ord, SingI ns)
            =&gt; Proxy (WeightOrder ns ord) -&gt; MonomialOrder n
weightOrder Proxy m m&#39; =
     comparing (calcOrderWeight (Proxy :: Proxy ns)) m m&#39;
  &lt;&gt; cmpMonomial (Proxy :: Proxy ord) m m&#39;
{-# INLINE weightOrder #-}

instance (KnownNat n, IsOrder n ord, SingI ws)
       =&gt; IsOrder n (WeightOrder ws ord) where
  cmpMonomial p = weightOrder p
  {-# INLINE [1] cmpMonomial #-}

instance (IsOrder n ord, IsOrder m ord&#39;, KnownNat m, KnownNat n, k ~ (n + m))
      =&gt; IsOrder k (ProductOrder n m ord ord&#39;) where
  cmpMonomial p = productOrder p
  {-# INLINE [1] cmpMonomial #-}

-- They&#39;re all total orderings.
instance IsOrder n Grevlex where
  cmpMonomial _ = grevlex
  {-# INLINE [1] cmpMonomial #-}

instance IsOrder n Revlex where
  cmpMonomial _ = revlex
  {-# INLINE [1] cmpMonomial #-}

instance IsOrder n Lex where
  cmpMonomial _ = lex
  {-# INLINE [1] cmpMonomial #-}

instance IsOrder n Grlex where
  cmpMonomial _ = grlex
  {-# INLINE [1] cmpMonomial #-}

-- | Class for Monomial orders.
class IsOrder n name =&gt; IsMonomialOrder n name where

-- Note that Revlex is not a monomial order.
-- This distinction is important when we calculate a quotient or Groebner basis.
instance IsMonomialOrder n Grlex
instance IsMonomialOrder n Grevlex
instance IsMonomialOrder n Lex
instance (KnownNat n, KnownNat m, IsMonomialOrder n o, IsMonomialOrder m o&#39;, k ~ (n + m))
      =&gt; IsMonomialOrder k (ProductOrder n m o o&#39;)
instance (KnownNat k, SingI ws, IsMonomialOrder k ord)
      =&gt; IsMonomialOrder k (WeightOrder ws ord)

lcmMonomial :: OrderedMonomial ord n -&gt; OrderedMonomial ord n -&gt; OrderedMonomial ord n
lcmMonomial (OrderedMonomial m) (OrderedMonomial n) = OrderedMonomial $ V.zipWithSame max m n

gcdMonomial :: OrderedMonomial ord n -&gt; OrderedMonomial ord n -&gt; OrderedMonomial ord n
gcdMonomial (OrderedMonomial m) (OrderedMonomial n) = OrderedMonomial $ V.zipWithSame P.min m n


divs :: OrderedMonomial ord n -&gt; OrderedMonomial ord n -&gt; Bool
(OrderedMonomial xs) `divs` (OrderedMonomial ys) = and $ V.toList $ V.zipWith (&lt;=) xs ys

isPowerOf :: KnownNat n =&gt; OrderedMonomial ord n -&gt; OrderedMonomial ord n -&gt; Bool
OrderedMonomial n `isPowerOf` OrderedMonomial m =
  case V.sFindIndices (&gt; 0) m of
    [ind] -&gt; F.sum n == V.sIndex ind n
    _     -&gt; False

tryDiv :: Field r =&gt; (r, OrderedMonomial ord n) -&gt; (r, OrderedMonomial ord n) -&gt; (r, OrderedMonomial ord n)
tryDiv (a, f) (b, g)
    | g `divs` f = (a * recip b, OrderedMonomial $ V.zipWithSame (-) (getMonomial f) (getMonomial g))
    | otherwise  = error &quot;cannot divide.&quot;

varMonom :: SNat n -&gt; Ordinal n -&gt; Monomial n
varMonom len o = V.replicate len 0 &amp; ix o .~ 1
{-# INLINE varMonom #-}

-- | Monomial order which can be use to calculate n-th elimination ideal of m-ary polynomial.
-- This should judge monomial to be bigger if it contains variables to eliminate.
class (IsMonomialOrder n ord, KnownNat n) =&gt; EliminationType n m ord
instance KnownNat n =&gt; EliminationType n m Lex
instance (KnownNat n, KnownNat m, IsMonomialOrder n ord, IsMonomialOrder m ord&#39;, k ~ (n + m), KnownNat k)
      =&gt; EliminationType k n (ProductOrder n m ord ord&#39;)
instance (IsMonomialOrder k ord, ones ~ (Replicate n 1), SingI ones,
          (Length ones :&lt;= k) ~ &#39;True, KnownNat k)
      =&gt; EliminationType k n (WeightOrder ones ord)

type EliminationOrder n m = ProductOrder n m Grevlex Grevlex

eliminationOrder :: SNat n -&gt; SNat m -&gt; EliminationOrder n m
eliminationOrder n m =
  withKnownNat n $ ProductOrder n m Grevlex Grevlex

sOnes :: Sing n -&gt; Sing (Replicate n 1)
sOnes n = sReplicate n (sing :: Sing 1)

weightedEliminationOrder :: SNat n -&gt; WeightedEliminationOrder n Grevlex
weightedEliminationOrder n =
  WeightOrder (sOnes n) (Proxy :: Proxy Grevlex)

type WeightedEliminationOrder (n :: Nat) (ord :: Type) =
  WeightOrder (Replicate n 1) ord

-- | Special ordering for ordered-monomials.
instance (Eq (Monomial n), IsOrder n name) =&gt; Ord (OrderedMonomial name n) where
  OrderedMonomial m `compare` OrderedMonomial n = cmpMonomial (Proxy :: Proxy name) m n

-- | For simplicity, we choose grevlex for the default monomial ordering (for the sake of efficiency).
instance {-# OVERLAPPING #-} Ord (Monomial n) where
  compare = grevlex

castMonomial :: (KnownNat m) =&gt; OrderedMonomial o n -&gt; OrderedMonomial o&#39; m
castMonomial = _Wrapped %~ fromList sing . V.toList

scastMonomial :: SNat m -&gt; OrderedMonomial o n -&gt; OrderedMonomial o m
scastMonomial sdim = _Wrapped %~ fromList sdim . V.toList

changeMonomialOrder :: o&#39; -&gt; OrderedMonomial ord n -&gt; OrderedMonomial o&#39; n
changeMonomialOrder _ = OrderedMonomial . getMonomial

changeMonomialOrderProxy :: Proxy o&#39; -&gt; OrderedMonomial ord n -&gt; OrderedMonomial o&#39; n
changeMonomialOrderProxy _ = OrderedMonomial . getMonomial

class    (IsMonomialOrder n ord) =&gt; IsMonomialOrder&#39; ord n
instance (IsMonomialOrder n ord) =&gt; IsMonomialOrder&#39; ord n

instance IsMonomialOrder&#39; ord n :=&gt; IsMonomialOrder n ord where
  ins = C.Sub Dict

-- | Monomial ordering which can do with monomials of arbitrary large arity.
type IsStrongMonomialOrder ord = Forall (IsMonomialOrder&#39; ord)

withStrongMonomialOrder :: forall ord n r proxy (proxy&#39; :: Nat -&gt; Type).
                           (IsStrongMonomialOrder ord)
                        =&gt; proxy ord -&gt; proxy&#39; n -&gt; (IsMonomialOrder n ord =&gt; r) -&gt; r
withStrongMonomialOrder _ _ r = r C.\\ dict
  where
    ismToPrim = (ins :: IsMonomialOrder&#39; ord n C.:- IsMonomialOrder n ord)
    primeInst = inst :: Forall (IsMonomialOrder&#39; ord) C.:- IsMonomialOrder&#39; ord n
    dict = ismToPrim `C.trans` primeInst

-- | Comparing monomials with different arity,
--   padding with @0@ at bottom of the shorter monomial to
--   make the length equal.
cmpAnyMonomial :: IsStrongMonomialOrder ord
               =&gt; Proxy ord -&gt; Monomial n -&gt; Monomial m -&gt; Ordering
cmpAnyMonomial pxy t t&#39; =
  let (l, u, u&#39;) = padVecs 0 t t&#39;
  in withStrongMonomialOrder pxy l $ cmpMonomial pxy u u&#39;

orderMonomial :: proxy ord -&gt; Monomial n -&gt; OrderedMonomial ord n
orderMonomial _ = OrderedMonomial
{-# INLINE orderMonomial #-}
</span> </pre></body></html></DOCTYPE>
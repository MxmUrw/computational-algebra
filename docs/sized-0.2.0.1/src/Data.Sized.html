<DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;=""><html xmlns="http://www.w3.org/1999/xhtml"><head><link href="style.css" type="text/css" rel="stylesheet"></link><script src="highlight.js" type="text/javascript"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE AllowAmbiguousTypes, ConstraintKinds, DataKinds               #-}</span> <span></span> <a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable, DeriveFoldable, DeriveFunctor             #-}</span> <span></span> <a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE DeriveTraversable, ExplicitNamespaces, FlexibleContexts       #-}</span> <span></span> <a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE FlexibleInstances, GADTs, GeneralizedNewtypeDeriving          #-}</span> <span></span> <a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE KindSignatures, LambdaCase, LiberalTypeSynonyms               #-}</span> <span></span> <a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses, NoMonomorphismRestriction              #-}</span> <span></span> <a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE PatternSynonyms, PolyKinds, ScopedTypeVariables, RankNTypes   #-}</span> <span></span> <a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving, TypeApplications, TypeFamilies            #-}</span> <span></span> <a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE TypeInType, TypeOperators, UndecidableInstances, ViewPatterns #-}</span> <span></span> <a name="line-10"></a><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-type-defaults -fno-warn-orphans #-}</span> <span></span> <a name="line-11"></a><span class="hs-pragma">{-# OPTIONS_GHC -fenable-rewrite-rules #-}</span> <span></span> <a name="line-12"></a><span class="hs-comment">-- | This module provides the functionality to make length-parametrized types</span> <span></span> <a name="line-13"></a><span class="hs-comment">--   from existing &#39;ListLike&#39; and &#39;Functor&#39; sequential types.</span> <span></span> <a name="line-14"></a><span class="hs-comment">--</span> <span></span> <a name="line-15"></a><span class="hs-comment">--   Most of the complexity of operations for @Sized f n a@ are the same as</span> <span></span> <a name="line-16"></a><span class="hs-comment">--   original operations for @f@. For example, &#39;!!&#39; is O(1) for</span> <span></span> <a name="line-17"></a><span class="hs-comment">--   @Sized Vector n a@ but O(i) for @Sized [] n a@.</span> <span></span> <a name="line-18"></a><span class="hs-comment">--</span> <span></span> <a name="line-19"></a><span class="hs-comment">--  This module also provides powerful view types and pattern synonyms to</span> <span></span> <a name="line-20"></a><span class="hs-comment">--  inspect the sized sequence. See &lt;#ViewsAndPatterns Views and Patterns&gt; for more detail.</span> <span></span> <a name="line-21"></a><span class="hs-keyword">module</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Sized</span> <span></span> <a name="line-22"></a><span></span> <span class="hs-special">(</span> <span></span> <span class="hs-comment">-- * Main Data-types</span> <span></span> <a name="line-23"></a><span></span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-type">Sized</span> </a><span class="hs-special">(</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#SomeSized"><span class="hs-identifier hs-type">SomeSized</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a name="line-24"></a><span></span> <a href="Data.Sized.Internal.html#instLL"><span class="hs-identifier hs-var">instLL</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.Internal.html#instFunctor"><span class="hs-identifier hs-var">instFunctor</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.Internal.html#ListLikeF"><span class="hs-identifier hs-type">ListLikeF</span> </a><span class="hs-special">,</span> <span></span> <a name="line-25"></a><span></span> <a href="Data.Sized.Internal.html#withListLikeF"><span class="hs-identifier hs-var">withListLikeF</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.Internal.html#withListLikeF%27"><span class="hs-identifier hs-var">withListLikeF&#39;</span> </a><span class="hs-special">,</span> <span></span> <a name="line-26"></a><span></span> <span class="hs-comment">-- * Accessors</span> <span></span> <a name="line-27"></a><span></span> <span class="hs-comment">-- ** Length information</span> <span></span> <a name="line-28"></a><span></span> <a href="Data.Sized.html#length"><span class="hs-identifier hs-var">length</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#sLength"><span class="hs-identifier hs-var">sLength</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#null"><span class="hs-identifier hs-var">null</span> </a><span class="hs-special">,</span> <span></span> <a name="line-29"></a><span></span> <span class="hs-comment">-- ** Indexing</span> <span></span> <a name="line-30"></a><span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#%21%21"><span class="hs-operator hs-var">!!</span> </a><span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#%25%21%21"><span class="hs-operator hs-var">%!!</span> </a><span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#index"><span class="hs-identifier hs-var">index</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#sIndex"><span class="hs-identifier hs-var">sIndex</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#head"><span class="hs-identifier hs-var">head</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#last"><span class="hs-identifier hs-var">last</span> </a><span class="hs-special">,</span> <span></span> <a name="line-31"></a><span></span> <a href="Data.Sized.html#uncons"><span class="hs-identifier hs-var">uncons</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#uncons%27"><span class="hs-identifier hs-var">uncons&#39;</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#unsnoc"><span class="hs-identifier hs-var">unsnoc</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#unsnoc%27"><span class="hs-identifier hs-var">unsnoc&#39;</span> </a><span class="hs-special">,</span> <span></span> <a name="line-32"></a><span></span> <span class="hs-comment">-- ** Slicing</span> <span></span> <a name="line-33"></a><span></span> <a href="Data.Sized.html#tail"><span class="hs-identifier hs-var">tail</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#init"><span class="hs-identifier hs-var">init</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#take"><span class="hs-identifier hs-var">take</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#takeAtMost"><span class="hs-identifier hs-var">takeAtMost</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#drop"><span class="hs-identifier hs-var">drop</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#splitAt"><span class="hs-identifier hs-var">splitAt</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#splitAtMost"><span class="hs-identifier hs-var">splitAtMost</span> </a><span class="hs-special">,</span> <span></span> <a name="line-34"></a><span></span> <span class="hs-comment">-- * Construction</span> <span></span> <a name="line-35"></a><span></span> <span class="hs-comment">-- ** Initialisation</span> <span></span> <a name="line-36"></a><span></span> <a href="Data.Sized.html#empty"><span class="hs-identifier hs-var">empty</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#singleton"><span class="hs-identifier hs-var">singleton</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#toSomeSized"><span class="hs-identifier hs-var">toSomeSized</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#replicate"><span class="hs-identifier hs-var">replicate</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#replicate%27"><span class="hs-identifier hs-var">replicate&#39;</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#generate"><span class="hs-identifier hs-var">generate</span> </a><span class="hs-special">,</span> <span></span> <a name="line-37"></a><span></span> <span class="hs-comment">-- ** Concatenation</span> <span></span> <a name="line-38"></a><span></span> <a href="Data.Sized.html#cons"><span class="hs-identifier hs-var">cons</span> </a><span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#%3C%7C"><span class="hs-operator hs-var">&lt;|</span> </a><span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#snoc"><span class="hs-identifier hs-var">snoc</span> </a><span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#%7C%3E"><span class="hs-operator hs-var">|&gt;</span> </a><span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#append"><span class="hs-identifier hs-var">append</span> </a><span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#%2B%2B"><span class="hs-operator hs-var">++</span> </a><span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#concat"><span class="hs-identifier hs-var">concat</span> </a><span class="hs-special">,</span> <span></span> <a name="line-39"></a><span></span> <span class="hs-comment">-- ** Zips</span> <span></span> <a name="line-40"></a><span></span> <a href="Data.Sized.html#zip"><span class="hs-identifier hs-var">zip</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#zipSame"><span class="hs-identifier hs-var">zipSame</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#zipWith"><span class="hs-identifier hs-var">zipWith</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#zipWithSame"><span class="hs-identifier hs-var">zipWithSame</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#unzip"><span class="hs-identifier hs-var">unzip</span> </a><span class="hs-special">,</span> <span></span> <a name="line-41"></a><span></span> <span class="hs-comment">-- * Transformation</span> <span></span> <a name="line-42"></a><span></span> <a href="Data.Sized.html#map"><span class="hs-identifier hs-var">map</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#fmap"><span class="hs-identifier hs-var">fmap</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#reverse"><span class="hs-identifier hs-var">reverse</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#intersperse"><span class="hs-identifier hs-var">intersperse</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#nub"><span class="hs-identifier hs-var">nub</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#sort"><span class="hs-identifier hs-var">sort</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#sortBy"><span class="hs-identifier hs-var">sortBy</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#insert"><span class="hs-identifier hs-var">insert</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#insertBy"><span class="hs-identifier hs-var">insertBy</span> </a><span class="hs-special">,</span> <span></span> <a name="line-43"></a><span></span> <span class="hs-comment">-- * Conversion</span> <span></span> <a name="line-44"></a><span></span> <span class="hs-comment">-- ** List</span> <span></span> <a name="line-45"></a><span></span> <a href="Data.Sized.html#toList"><span class="hs-identifier hs-var">toList</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#fromList"><span class="hs-identifier hs-var">fromList</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#fromList%27"><span class="hs-identifier hs-var">fromList&#39;</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#unsafeFromList"><span class="hs-identifier hs-var">unsafeFromList</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#unsafeFromList%27"><span class="hs-identifier hs-var">unsafeFromList&#39;</span> </a><span class="hs-special">,</span> <span></span> <a name="line-46"></a><span></span> <a href="Data.Sized.html#fromListWithDefault"><span class="hs-identifier hs-var">fromListWithDefault</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#fromListWithDefault%27"><span class="hs-identifier hs-var">fromListWithDefault&#39;</span> </a><span class="hs-special">,</span> <span></span> <a name="line-47"></a><span></span> <span class="hs-comment">-- ** Base container</span> <span></span> <a name="line-48"></a><span></span> <a href="Data.Sized.html#unsized"><span class="hs-identifier hs-var">unsized</span> </a><span class="hs-special">,</span> <span></span> <a name="line-49"></a><span></span> <a href="Data.Sized.html#toSized"><span class="hs-identifier hs-var">toSized</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#toSized%27"><span class="hs-identifier hs-var">toSized&#39;</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#unsafeToSized"><span class="hs-identifier hs-var">unsafeToSized</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#unsafeToSized%27"><span class="hs-identifier hs-var">unsafeToSized&#39;</span> </a><span class="hs-special">,</span> <span></span> <a name="line-50"></a><span></span> <a href="Data.Sized.html#toSizedWithDefault"><span class="hs-identifier hs-var">toSizedWithDefault</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#toSizedWithDefault%27"><span class="hs-identifier hs-var">toSizedWithDefault&#39;</span> </a><span class="hs-special">,</span> <span></span> <a name="line-51"></a><span></span> <span class="hs-comment">-- * Querying</span> <span></span> <a name="line-52"></a><span></span> <span class="hs-comment">-- ** Partitioning</span> <span></span> <a name="line-53"></a><span></span> <a href="Data.Sized.html#Partitioned"><span class="hs-identifier hs-type">Partitioned</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a name="line-54"></a><span></span> <a href="Data.Sized.html#takeWhile"><span class="hs-identifier hs-var">takeWhile</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#dropWhile"><span class="hs-identifier hs-var">dropWhile</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#span"><span class="hs-identifier hs-var">span</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#break"><span class="hs-identifier hs-var">break</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#partition"><span class="hs-identifier hs-var">partition</span> </a><span class="hs-special">,</span> <span></span> <a name="line-55"></a><span></span> <span class="hs-comment">-- ** Searching</span> <span></span> <a name="line-56"></a><span></span> <a href="Data.Sized.html#elem"><span class="hs-identifier hs-var">elem</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#notElem"><span class="hs-identifier hs-var">notElem</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#find"><span class="hs-identifier hs-var">find</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#findF"><span class="hs-identifier hs-var">findF</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#findIndex"><span class="hs-identifier hs-var">findIndex</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#findIndexIF"><span class="hs-identifier hs-var">findIndexIF</span> </a><span class="hs-special">,</span> <span></span> <a name="line-57"></a><span></span> <a href="Data.Sized.html#sFindIndex"><span class="hs-identifier hs-var">sFindIndex</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#sFindIndexIF"><span class="hs-identifier hs-var">sFindIndexIF</span> </a><span class="hs-special">,</span> <span></span> <a name="line-58"></a><span></span> <a href="Data.Sized.html#findIndices"><span class="hs-identifier hs-var">findIndices</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#findIndicesIF"><span class="hs-identifier hs-var">findIndicesIF</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#sFindIndices"><span class="hs-identifier hs-var">sFindIndices</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#sFindIndicesIF"><span class="hs-identifier hs-var">sFindIndicesIF</span> </a><span class="hs-special">,</span> <span></span> <a name="line-59"></a><span></span> <a href="Data.Sized.html#elemIndex"><span class="hs-identifier hs-var">elemIndex</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#sElemIndex"><span class="hs-identifier hs-var">sElemIndex</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#sUnsafeElemIndex"><span class="hs-identifier hs-var">sUnsafeElemIndex</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#elemIndices"><span class="hs-identifier hs-var">elemIndices</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#sElemIndices"><span class="hs-identifier hs-var">sElemIndices</span> </a><span class="hs-special">,</span> <span></span> <a name="line-60"></a><span></span> <span class="hs-comment">-- * Views and Patterns</span> <span></span> <a name="line-61"></a><span></span> <span class="hs-comment">-- $ViewsAndPatterns</span> <span></span> <a name="line-62"></a><span></span> <a name="line-63"></a><span></span> <span class="hs-comment">-- ** Views</span> <span></span> <a name="line-64"></a><span></span> <span class="hs-comment">-- $views</span> <span></span> <a name="line-65"></a><span></span> <a name="line-66"></a><span></span> <span class="hs-comment">-- ** Patterns</span> <span></span> <a name="line-67"></a><span></span> <span class="hs-comment">-- $patterns</span> <span></span> <a name="line-68"></a><span></span> <a name="line-69"></a><span></span> <span class="hs-comment">-- ** Definitions</span> <span></span> <a name="line-70"></a><span></span> <a href="Data.Sized.html#viewCons"><span class="hs-identifier hs-var">viewCons</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#ConsView"><span class="hs-identifier hs-type">ConsView</span> </a><span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#viewSnoc"><span class="hs-identifier hs-var">viewSnoc</span> </a><span class="hs-special">,</span> <span></span> <a href="Data.Sized.html#SnocView"><span class="hs-identifier hs-type">SnocView</span> </a><span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <a name="line-71"></a><span></span> <a name="line-72"></a><span></span> <span class="hs-identifier">pattern</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#%3A%3C"><span class="hs-operator hs-var">:&lt;</span> </a><span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier">pattern</span> <span></span> <a href="Data.Sized.html#NilL"><span class="hs-identifier hs-var">NilL</span> </a><span></span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier">pattern</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#%3A%3E"><span class="hs-operator hs-var">:&gt;</span> </a><span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier">pattern</span> <span></span> <a href="Data.Sized.html#NilR"><span class="hs-identifier hs-var">NilR</span> </a><span class="hs-special">,</span> <span></span> <a name="line-73"></a><span></span> <span class="hs-special">)</span> <span></span> <span class="hs-keyword">where</span> <span></span> <a name="line-74"></a><span></span> <a name="line-75"></a><span class="hs-keyword">import</span> <span></span> <a href="Data.Sized.Internal.html"><span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Sized</span> <span class="hs-operator">.</span> <span class="hs-identifier">Internal</span> </a><span></span> <a name="line-76"></a><span></span> <a name="line-77"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Applicative</span> <span></span> <span class="hs-special">(</span> <span class="hs-special">(</span> <span class="hs-operator hs-var">&lt;$&gt;</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <span class="hs-operator hs-var">&lt;*&gt;</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">ZipList</span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-78"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Control</span> <span class="hs-operator">.</span> <span class="hs-identifier">Lens</span> <span class="hs-operator">.</span> <span class="hs-identifier">Indexed</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">FoldableWithIndex</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">ifind</span> <span class="hs-special">)</span> <span></span> <a name="line-79"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Foldable</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Foldable</span> <span class="hs-special">)</span> <span></span> <a name="line-80"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Foldable</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">F</span> <span></span> <a name="line-81"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Kind</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Type</span> <span class="hs-special">)</span> <span></span> <a name="line-82"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">List</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">L</span> <span></span> <a name="line-83"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">ListLike</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">ListLike</span> <span class="hs-special">)</span> <span></span> <a name="line-84"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">ListLike</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">LL</span> <span></span> <a name="line-85"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">MonoTraversable</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">MT</span> <span></span> <a name="line-86"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monoid</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Endo</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">First</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-87"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Sequence</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">Seq</span> <span></span> <a name="line-88"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Singletons</span> <span class="hs-operator">.</span> <span class="hs-identifier">TypeLits</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">withKnownNat</span> <span class="hs-special">)</span> <span></span> <a name="line-89"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Singletons</span> <span class="hs-operator">.</span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">PNum</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">POrd</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">SOrd</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-90"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Singletons</span> <span class="hs-operator">.</span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Sing</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">SingI</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-91"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Singletons</span> <span class="hs-operator">.</span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">withSing</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">withSingI</span> <span class="hs-special">)</span> <span></span> <a name="line-92"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Singletons</span> <span class="hs-operator">.</span> <span class="hs-identifier">Prelude</span> <span class="hs-operator">.</span> <span class="hs-identifier">Enum</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">PEnum</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-93"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Type</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monomorphic</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Monomorphic</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-94"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Type</span> <span class="hs-operator">.</span> <span class="hs-identifier">Monomorphic</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Monomorphicable</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-95"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Type</span> <span class="hs-operator">.</span> <span class="hs-identifier">Natural</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">Peano</span> <span></span> <a name="line-96"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Type</span> <span class="hs-operator">.</span> <span class="hs-identifier">Natural</span> <span class="hs-operator">.</span> <span class="hs-identifier">Class</span> <span></span> <a name="line-97"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Type</span> <span class="hs-operator">.</span> <span class="hs-identifier">Ordinal</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">HasOrdinal</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Ordinal</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">enumOrdinal</span> <span class="hs-special">)</span> <span></span> <a name="line-98"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Type</span> <span class="hs-operator">.</span> <span class="hs-identifier">Ordinal</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">ordToInt</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">unsafeFromInt</span> <span class="hs-special">)</span> <span></span> <a name="line-99"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Typeable</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Typeable</span> <span class="hs-special">)</span> <span></span> <a name="line-100"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Vector</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">V</span> <span></span> <a name="line-101"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Vector</span> <span class="hs-operator">.</span> <span class="hs-identifier">Storable</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">SV</span> <span></span> <a name="line-102"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Data</span> <span class="hs-operator">.</span> <span class="hs-identifier">Vector</span> <span class="hs-operator">.</span> <span class="hs-identifier">Unboxed</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">UV</span> <span></span> <a name="line-103"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">GHC</span> <span class="hs-operator">.</span> <span class="hs-identifier">TypeLits</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">TL</span> <span></span> <a name="line-104"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Bool</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Enum</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Eq</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-105"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Functor</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Int</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Maybe</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-106"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Num</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Ord</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">Ordering</span> <span class="hs-special">)</span> <span></span> <a name="line-107"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Show</span> <span></span> <span class="hs-special">(</span> <span class="hs-glyph">..</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">flip</span> <span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-var">fst</span> <span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <span class="hs-operator hs-var">$</span> <span class="hs-special">)</span> <span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <span class="hs-operator hs-var">.</span> <span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="line-108"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-keyword">qualified</span> <span></span> <span class="hs-identifier">Prelude</span> <span></span> <span class="hs-keyword">as</span> <span></span> <span class="hs-identifier">P</span> <span></span> <a name="line-109"></a><span class="hs-keyword">import</span> <span></span> <span class="hs-identifier">Unsafe</span> <span class="hs-operator">.</span> <span class="hs-identifier">Coerce</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">unsafeCoerce</span> <span class="hs-special">)</span> <span></span> <a name="line-110"></a><span></span> <a name="line-111"></a><span class="hs-comment">--------------------------------------------------------------------------------</span> <span></span> <a name="line-112"></a><span class="hs-comment">-- Main data-types</span> <span></span> <a name="line-113"></a><span class="hs-comment">--------------------------------------------------------------------------------</span> <span></span> <a name="line-114"></a><span></span> <a name="line-115"></a><span class="hs-comment">-- | &#39;Sized&#39; vector with the length is existentially quantified.</span> <span></span> <a name="line-116"></a><span class="hs-comment">--   This type is used mostly when the return type&#39;s length cannot</span> <span></span> <a name="line-117"></a><span class="hs-comment">--   be statically determined beforehand.</span> <span></span> <a name="line-118"></a><span class="hs-comment">--</span> <span></span> <a name="line-119"></a><span class="hs-comment">-- @SomeSized sn xs :: SomeSized f a@ stands for the &#39;Sized&#39; sequence</span> <span></span> <a name="line-120"></a><span class="hs-comment">-- @xs@ of element type @a@ and length @sn@.</span> <span></span> <a name="line-121"></a><span class="hs-comment">--</span> <span></span> <a name="line-122"></a><span class="hs-comment">-- Since 0.1.0.0</span> <span></span> <a name="line-123"></a><span class="hs-keyword">data</span> <span></span> <a name="SomeSized"><a href="Data.Sized.html#SomeSized"><span class="hs-identifier">SomeSized</span> </a></a><span></span> <a name="local-1627636472"><a href="#local-1627636472"><span class="hs-identifier">f</span> </a></a><span></span> <a name="local-1627636473"><a href="#local-1627636473"><span class="hs-identifier">nat</span> </a></a><span></span> <a name="local-1627636474"><a href="#local-1627636474"><span class="hs-identifier">a</span> </a></a><span></span> <span class="hs-keyword">where</span> <span></span> <a name="line-124"></a><span></span> <a name="SomeSized"><a href="Data.Sized.html#SomeSized"><span class="hs-identifier">SomeSized</span> </a></a><span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">ListLike</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636476"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636477"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636477"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <a name="line-125"></a><span></span> <span class="hs-glyph">=&gt;</span> <span></span> <span class="hs-identifier hs-type">Sing</span> <span></span> <a href="#local-1627636478"><span class="hs-identifier hs-type">n</span> </a><span></span> <a name="line-126"></a><span></span> <span class="hs-glyph">-&gt;</span> <span></span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-type">Sized</span> </a><span></span> <a href="#local-1627636476"><span class="hs-identifier hs-type">f</span> </a><span></span> <span class="hs-special">(</span> <a href="#local-1627636478"><span class="hs-identifier hs-type">n</span> </a><span></span> <span class="hs-glyph">::</span> <span></span> <a href="#local-1627636479"><span class="hs-identifier hs-type">nat</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636477"><span class="hs-identifier hs-type">a</span> </a><span></span> <a name="line-127"></a><span></span> <span class="hs-glyph">-&gt;</span> <span></span> <a href="Data.Sized.html#SomeSized"><span class="hs-identifier hs-type">SomeSized</span> </a><span></span> <a href="#local-1627636476"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636479"><span class="hs-identifier hs-type">nat</span> </a><span></span> <a href="#local-1627636477"><span class="hs-identifier hs-type">a</span> </a><span></span> <a name="line-128"></a><span></span> <a name="line-129"></a><span class="hs-keyword">deriving</span> <span></span> <span class="hs-keyword">instance</span> <span></span> <span class="hs-identifier hs-type">Typeable</span> <span></span> <a href="Data.Sized.html#SomeSized"><span class="hs-identifier hs-type">SomeSized</span> </a><span></span> <a name="line-130"></a><span></span> <a name="line-131"></a><span class="hs-keyword">instance</span> <span></span> <span class="hs-identifier hs-type">Show</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627637032"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627637033"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">=&gt;</span> <span></span> <span class="hs-identifier hs-type">Show</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#SomeSized"><span class="hs-identifier hs-type">SomeSized</span> </a><span></span> <a href="#local-1627637032"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627637034"><span class="hs-identifier hs-type">nat</span> </a><span></span> <a href="#local-1627637033"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-keyword">where</span> <span></span> <a name="line-132"></a><span></span> <a name="local-1912609161"><span class="hs-identifier">showsPrec</span> </a><span></span> <a name="local-1627637035"><a href="#local-1627637035"><span class="hs-identifier">d</span> </a></a><span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#SomeSized"><span class="hs-identifier hs-var">SomeSized</span> </a><span></span> <span class="hs-identifier">_</span> <span></span> <a name="local-1627637036"><a href="#local-1627637036"><span class="hs-identifier">s</span> </a></a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">=</span> <span></span> <span class="hs-identifier hs-var">P</span> <span class="hs-operator hs-var">.</span> <span class="hs-identifier hs-var">showParen</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627637035"><span class="hs-identifier hs-var">d</span> </a><span></span> <span class="hs-operator hs-var">&gt;</span> <span></span> <span class="hs-number">9</span> <span class="hs-special">)</span> <span></span> <span class="hs-operator hs-var">$</span> <span></span> <a name="line-133"></a><span></span> <span class="hs-identifier hs-var">P</span> <span class="hs-operator hs-var">.</span> <span class="hs-identifier hs-var">showString</span> <span></span> <span class="hs-string">&quot;SomeSized _ &quot;</span> <span></span> <span class="hs-operator hs-var">.</span> <span></span> <span class="hs-identifier hs-var">showsPrec</span> <span></span> <span class="hs-number">10</span> <span></span> <a href="#local-1627637036"><span class="hs-identifier hs-var">s</span> </a><span></span> <a name="line-134"></a><span class="hs-keyword">instance</span> <span></span> <span class="hs-identifier hs-type">Eq</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627637027"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627637028"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">=&gt;</span> <span></span> <span class="hs-identifier hs-type">Eq</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#SomeSized"><span class="hs-identifier hs-type">SomeSized</span> </a><span></span> <a href="#local-1627637027"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627637029"><span class="hs-identifier hs-type">nat</span> </a><span></span> <a href="#local-1627637028"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-keyword">where</span> <span></span> <a name="line-135"></a><span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#SomeSized"><span class="hs-identifier hs-var">SomeSized</span> </a><span></span> <span class="hs-identifier">_</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-var">Sized</span> </a><span></span> <a name="local-1627637030"><a href="#local-1627637030"><span class="hs-identifier">xs</span> </a></a><span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <a name="local-805306535"><span class="hs-operator">==</span> </a><span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#SomeSized"><span class="hs-identifier hs-var">SomeSized</span> </a><span></span> <span class="hs-identifier">_</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-var">Sized</span> </a><span></span> <a name="local-1627637031"><a href="#local-1627637031"><span class="hs-identifier">ys</span> </a></a><span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <span class="hs-glyph">=</span> <span></span> <a href="#local-1627637030"><span class="hs-identifier hs-var">xs</span> </a><span></span> <span class="hs-operator hs-var">==</span> <span></span> <a href="#local-1627637031"><span class="hs-identifier hs-var">ys</span> </a><span></span> <a name="line-136"></a><span></span> <a name="line-137"></a><span class="hs-identifier">demote&#39;</span> <span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-identifier hs-type">HasOrdinal</span> <span></span> <a href="#local-1627636865"><span class="hs-identifier hs-type">nat</span> </a><span></span> <span class="hs-glyph">=&gt;</span> <span></span> <span class="hs-identifier hs-type">Sing</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636866"><span class="hs-identifier hs-type">n</span> </a><span></span> <span class="hs-glyph">::</span> <span></span> <a href="#local-1627636865"><span class="hs-identifier hs-type">nat</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">-&gt;</span> <span></span> <span class="hs-identifier hs-type">MonomorphicRep</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Sing</span> <span></span> <span class="hs-glyph">::</span> <span></span> <a href="#local-1627636865"><span class="hs-identifier hs-type">nat</span> </a><span></span> <span class="hs-glyph">-&gt;</span> <span></span> <span class="hs-identifier hs-type">Type</span> <span class="hs-special">)</span> <span></span> <a name="line-138"></a><a name="demote%27"><a href="Data.Sized.html#demote%27"><span class="hs-identifier">demote&#39;</span> </a></a><span></span> <span class="hs-glyph">=</span> <span></span> <span class="hs-identifier hs-var">demote</span> <span></span> <span class="hs-operator hs-var">.</span> <span></span> <span class="hs-identifier hs-var">Monomorphic</span> <span></span> <a name="line-139"></a><span class="hs-pragma">{-# SPECIALISE demote&#39; :: Sing (n :: TL.Nat) -&gt; P.Integer #-}</span> <span></span> <a name="line-140"></a><span class="hs-pragma">{-# SPECIALISE demote&#39; :: Sing (n :: Peano.Nat) -&gt; P.Integer #-}</span> <span></span> <a name="line-141"></a><span></span> <a name="line-142"></a><span class="hs-comment">--------------------------------------------------------------------------------</span> <span></span> <a name="line-143"></a><span class="hs-comment">-- Accessors</span> <span></span> <a name="line-144"></a><span class="hs-comment">--------------------------------------------------------------------------------</span> <span></span> <a name="line-145"></a><span></span> <a name="line-146"></a><span class="hs-comment">--------------------------------------------------------------------------------</span> <span></span> <a name="line-147"></a><span class="hs-comment">--- Length infromation</span> <span></span> <a name="line-148"></a><span class="hs-comment">--------------------------------------------------------------------------------</span> <span></span> <a name="line-149"></a><span></span> <a name="line-150"></a><span class="hs-comment">-- | Returns the length of wrapped containers.</span> <span></span> <a name="line-151"></a><span class="hs-comment">--   If you use @unsafeFromList@ or similar unsafe functions,</span> <span></span> <a name="line-152"></a><span class="hs-comment">--   this function may return different value from type-parameterized length.</span> <span></span> <a name="line-153"></a><span class="hs-comment">--</span> <span></span> <a name="line-154"></a><span class="hs-comment">-- Since 0.1.0.0</span> <span></span> <a name="line-155"></a><span class="hs-identifier">length</span> <span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-identifier hs-type">ListLike</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636859"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636860"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636860"><span class="hs-identifier hs-type">a</span> </a><span></span> <span class="hs-glyph">=&gt;</span> <span></span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-type">Sized</span> </a><span></span> <a href="#local-1627636859"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636861"><span class="hs-identifier hs-type">n</span> </a><span></span> <a href="#local-1627636860"><span class="hs-identifier hs-type">a</span> </a><span></span> <span class="hs-glyph">-&gt;</span> <span></span> <span class="hs-identifier hs-type">Int</span> <span></span> <a name="line-156"></a><a name="length"><a href="Data.Sized.html#length"><span class="hs-identifier">length</span> </a></a><span></span> <span class="hs-glyph">=</span> <span></span> <span class="hs-identifier hs-var">LL</span> <span class="hs-operator hs-var">.</span> <span class="hs-identifier hs-var">length</span> <span></span> <span class="hs-operator hs-var">.</span> <span></span> <span class="hs-identifier">runSized</span> <span></span> <a name="line-157"></a><span class="hs-pragma">{-# INLINE [1] length #-}</span> <span></span> <a name="line-158"></a><span class="hs-pragma">{-# RULES
&quot;length/0&quot; [~1] forall (xs :: Sized f 0 a).
  length xs = 0
&quot;length/Z&quot; [~1] forall (xs :: Sized f &#39;Peano.Z a).
  length xs = 0
  #-}</span> <span></span> <a name="line-164"></a><span></span> <a name="line-165"></a><span class="hs-comment">-- | @Sing@ version of &#39;length&#39;.</span> <span></span> <a name="line-166"></a><span class="hs-comment">--</span> <span></span> <a name="line-167"></a><span class="hs-comment">-- Since 0.2.0.0</span> <span></span> <a name="line-168"></a><span class="hs-identifier">sLength</span> <span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-keyword">forall</span> <span></span> <a name="local-1627636856"><a href="#local-1627636856"><span class="hs-identifier">f</span> </a></a><span></span> <span class="hs-special">(</span> <a name="local-1627636857"><a href="#local-1627636857"><span class="hs-identifier">n</span> </a></a><span></span> <span class="hs-glyph">::</span> <span></span> <a href="#local-1627636855"><span class="hs-identifier hs-type">nat</span> </a><span class="hs-special">)</span> <span></span> <a name="local-1627636858"><a href="#local-1627636858"><span class="hs-identifier">a</span> </a></a><span class="hs-operator">.</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">HasOrdinal</span> <span></span> <a href="#local-1627636855"><span class="hs-identifier hs-type">nat</span> </a><span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">ListLike</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636856"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636858"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636858"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <a name="line-169"></a><span></span> <span class="hs-glyph">=&gt;</span> <span></span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-type">Sized</span> </a><span></span> <a href="#local-1627636856"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636857"><span class="hs-identifier hs-type">n</span> </a><span></span> <a href="#local-1627636858"><span class="hs-identifier hs-type">a</span> </a><span></span> <span class="hs-glyph">-&gt;</span> <span></span> <span class="hs-identifier hs-type">Sing</span> <span></span> <a href="#local-1627636857"><span class="hs-identifier hs-type">n</span> </a><span></span> <a name="line-170"></a><a name="sLength"><a href="Data.Sized.html#sLength"><span class="hs-identifier">sLength</span> </a></a><span></span> <span class="hs-special">(</span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-var">Sized</span> </a><span></span> <a name="local-1627636867"><a href="#local-1627636867"><span class="hs-identifier">xs</span> </a></a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">=</span> <span></span> <a name="line-171"></a><span></span> <span class="hs-keyword">case</span> <span></span> <span class="hs-identifier hs-var">promote</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-var">P</span> <span class="hs-operator hs-var">.</span> <span class="hs-identifier hs-var">fromIntegral</span> <span></span> <span class="hs-operator hs-var">$</span> <span></span> <span class="hs-identifier hs-var">LL</span> <span class="hs-operator hs-var">.</span> <span class="hs-identifier hs-var">length</span> <span></span> <a href="#local-1627636867"><span class="hs-identifier hs-var">xs</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-keyword">of</span> <span></span> <a name="line-172"></a><span></span> <span class="hs-identifier hs-var">Monomorphic</span> <span></span> <span class="hs-special">(</span> <a name="local-1627636869"><a href="#local-1627636869"><span class="hs-identifier">n</span> </a></a><span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-identifier hs-type">Sing</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636868"><span class="hs-identifier hs-type">k</span> </a><span></span> <span class="hs-glyph">::</span> <span></span> <a href="#local-1627636855"><span class="hs-identifier hs-type">nat</span> </a><span class="hs-special">)</span> <span class="hs-special">)</span> <span></span> <span class="hs-glyph">-&gt;</span> <span></span> <span class="hs-identifier hs-var">unsafeCoerce</span> <span></span> <a href="#local-1627636869"><span class="hs-identifier hs-var">n</span> </a><span></span> <a name="line-173"></a><span class="hs-pragma">{-# INLINE[2] sLength #-}</span> <span></span> <a name="line-174"></a><span class="hs-pragma">{-# RULES
&quot;sLength/KnownNat&quot; [~1] forall (xs :: TL.KnownNat n =&gt; Sized f n a).
  sLength xs = sing :: Sing n
&quot;sLength/SingI&quot; [~2] forall (xs :: SingI n =&gt; Sized f n a).
  sLength xs = sing :: Sing n
  #-}</span> <span></span> <a name="line-180"></a><span></span> <a name="line-181"></a><span class="hs-comment">-- | Test if the sequence is empty or not.</span> <span></span> <a name="line-182"></a><span class="hs-comment">--</span> <span></span> <a name="line-183"></a><span class="hs-comment">-- Since 0.1.0.0</span> <span></span> <a name="line-184"></a><span class="hs-identifier">null</span> <span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-identifier hs-type">ListLike</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636852"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636853"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636853"><span class="hs-identifier hs-type">a</span> </a><span></span> <span class="hs-glyph">=&gt;</span> <span></span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-type">Sized</span> </a><span></span> <a href="#local-1627636852"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636854"><span class="hs-identifier hs-type">n</span> </a><span></span> <a href="#local-1627636853"><span class="hs-identifier hs-type">a</span> </a><span></span> <span class="hs-glyph">-&gt;</span> <span></span> <span class="hs-identifier hs-type">Bool</span> <span></span> <a name="line-185"></a><a name="null"><a href="Data.Sized.html#null"><span class="hs-identifier">null</span> </a></a><span></span> <span class="hs-glyph">=</span> <span></span> <span class="hs-identifier hs-var">LL</span> <span class="hs-operator hs-var">.</span> <span class="hs-identifier hs-var">null</span> <span></span> <span class="hs-operator hs-var">.</span> <span></span> <span class="hs-identifier">runSized</span> <span></span> <a name="line-186"></a><span class="hs-pragma">{-# INLINE CONLIKE [1] null #-}</span> <span></span> <a name="line-187"></a><span class="hs-pragma">{-# RULES
&quot;null/0&quot; [~1] forall (xs :: Sized f 0 a).
  null xs = True

&quot;null/Z&quot; [~1] forall (xs :: Sized f &#39;Peano.Z a).
  null xs = True
#-}</span> <span></span> <a name="line-194"></a><span></span> <a name="line-195"></a><span class="hs-comment">--------------------------------------------------------------------------------</span> <span></span> <a name="line-196"></a><span class="hs-comment">--- Indexing</span> <span></span> <a name="line-197"></a><span class="hs-comment">--------------------------------------------------------------------------------</span> <span></span> <a name="line-198"></a><span></span> <a name="line-199"></a><span class="hs-comment">-- | (Unsafe) indexing with @Int@s.</span> <span></span> <a name="line-200"></a><span class="hs-comment">--   If you want to check boundary statically, use &#39;%!!&#39; or &#39;sIndex&#39;.</span> <span></span> <a name="line-201"></a><span class="hs-comment">--</span> <span></span> <a name="line-202"></a><span class="hs-comment">-- Since 0.1.0.0</span> <span></span> <a name="line-203"></a><span class="hs-special">(</span> <span class="hs-operator">!!</span> <span class="hs-special">)</span> <span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">ListLike</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636849"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636850"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636850"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">=&gt;</span> <span></span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-type">Sized</span> </a><span></span> <a href="#local-1627636849"><span class="hs-identifier hs-type">f</span> </a><span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Succ</span> <span></span> <a href="#local-1627636851"><span class="hs-identifier hs-type">m</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636850"><span class="hs-identifier hs-type">a</span> </a><span></span> <span class="hs-glyph">-&gt;</span> <span></span> <span class="hs-identifier hs-type">Int</span> <span></span> <span class="hs-glyph">-&gt;</span> <span></span> <a href="#local-1627636850"><span class="hs-identifier hs-type">a</span> </a><span></span> <a name="line-204"></a><a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-var">Sized</span> </a><span></span> <a name="local-1627636870"><a href="#local-1627636870"><span class="hs-identifier">xs</span> </a></a><span></span> <a name="%21%21"><a href="Data.Sized.html#%21%21"><span class="hs-operator">!!</span> </a></a><span></span> <a name="local-1627636871"><a href="#local-1627636871"><span class="hs-identifier">n</span> </a></a><span></span> <span class="hs-glyph">=</span> <span></span> <span class="hs-identifier hs-var">LL</span> <span class="hs-operator hs-var">.</span> <span class="hs-identifier hs-var">index</span> <span></span> <a href="#local-1627636870"><span class="hs-identifier hs-var">xs</span> </a><span></span> <a href="#local-1627636871"><span class="hs-identifier hs-var">n</span> </a><span></span> <a name="line-205"></a><span class="hs-pragma">{-# INLINE (!!) #-}</span> <span></span> <a name="line-206"></a><span></span> <a name="line-207"></a><span class="hs-comment">-- | Safe indexing with &#39;Ordinal&#39;s.</span> <span></span> <a name="line-208"></a><span class="hs-comment">--</span> <span></span> <a name="line-209"></a><span class="hs-comment">-- Since 0.1.0.0</span> <span></span> <a name="line-210"></a><span class="hs-special">(</span> <span class="hs-operator">%!!</span> <span class="hs-special">)</span> <span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">HasOrdinal</span> <span></span> <a href="#local-1627636845"><span class="hs-identifier hs-type">nat</span> </a><span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">LL</span> <span class="hs-operator hs-type">.</span> <span class="hs-identifier hs-type">ListLike</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636846"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636847"><span class="hs-identifier hs-type">c</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636847"><span class="hs-identifier hs-type">c</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">=&gt;</span> <span></span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-type">Sized</span> </a><span></span> <a href="#local-1627636846"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636848"><span class="hs-identifier hs-type">n</span> </a><span></span> <a href="#local-1627636847"><span class="hs-identifier hs-type">c</span> </a><span></span> <span class="hs-glyph">-&gt;</span> <span></span> <span class="hs-identifier hs-type">Ordinal</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636848"><span class="hs-identifier hs-type">n</span> </a><span></span> <span class="hs-glyph">::</span> <span></span> <a href="#local-1627636845"><span class="hs-identifier hs-type">nat</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">-&gt;</span> <span></span> <a href="#local-1627636847"><span class="hs-identifier hs-type">c</span> </a><span></span> <a name="line-211"></a><a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-var">Sized</span> </a><span></span> <a name="local-1627636872"><a href="#local-1627636872"><span class="hs-identifier">xs</span> </a></a><span></span> <a name="%25%21%21"><a href="Data.Sized.html#%25%21%21"><span class="hs-operator">%!!</span> </a></a><span></span> <a name="local-1627636873"><a href="#local-1627636873"><span class="hs-identifier">n</span> </a></a><span></span> <span class="hs-glyph">=</span> <span></span> <span class="hs-identifier hs-var">LL</span> <span class="hs-operator hs-var">.</span> <span class="hs-identifier hs-var">index</span> <span></span> <a href="#local-1627636872"><span class="hs-identifier hs-var">xs</span> </a><span></span> <span class="hs-operator hs-var">$</span> <span></span> <span class="hs-identifier hs-var">P</span> <span class="hs-operator hs-var">.</span> <span class="hs-identifier hs-var">fromIntegral</span> <span></span> <span class="hs-operator hs-var">$</span> <span></span> <span class="hs-identifier hs-var">ordToInt</span> <span></span> <a href="#local-1627636873"><span class="hs-identifier hs-var">n</span> </a><span></span> <a name="line-212"></a><span class="hs-pragma">{-# INLINE (%!!) #-}</span> <span></span> <a name="line-213"></a><span class="hs-pragma">{-# SPECIALISE (%!!) :: Sized [] (n :: TL.Nat) a -&gt; Ordinal n -&gt; a #-}</span> <span></span> <a name="line-214"></a><span class="hs-pragma">{-# SPECIALISE (%!!) :: Sized [] (n :: Peano.Nat) a -&gt; Ordinal n -&gt; a #-}</span> <span></span> <a name="line-215"></a><span class="hs-pragma">{-# SPECIALISE (%!!) :: Sized V.Vector (n :: TL.Nat) a -&gt; Ordinal n -&gt; a #-}</span> <span></span> <a name="line-216"></a><span class="hs-pragma">{-# SPECIALISE (%!!) :: Sized V.Vector (n :: Peano.Nat) a -&gt; Ordinal n -&gt; a #-}</span> <span></span> <a name="line-217"></a><span class="hs-pragma">{-# SPECIALISE (%!!) :: UV.Unbox a =&gt; Sized UV.Vector (n :: TL.Nat) a -&gt; Ordinal n -&gt; a #-}</span> <span></span> <a name="line-218"></a><span class="hs-pragma">{-# SPECIALISE (%!!) :: UV.Unbox a =&gt; Sized UV.Vector (n :: Peano.Nat) a -&gt; Ordinal n -&gt; a #-}</span> <span></span> <a name="line-219"></a><span class="hs-pragma">{-# SPECIALISE (%!!) :: SV.Storable a =&gt; Sized SV.Vector (n :: TL.Nat) a -&gt; Ordinal n -&gt; a #-}</span> <span></span> <a name="line-220"></a><span class="hs-pragma">{-# SPECIALISE (%!!) :: SV.Storable a =&gt; Sized SV.Vector (n :: Peano.Nat) a -&gt; Ordinal n -&gt; a #-}</span> <span></span> <a name="line-221"></a><span class="hs-pragma">{-# SPECIALISE (%!!) :: Sized Seq.Seq (n :: TL.Nat) a -&gt; Ordinal n -&gt; a #-}</span> <span></span> <a name="line-222"></a><span class="hs-pragma">{-# SPECIALISE (%!!) :: Sized Seq.Seq (n :: Peano.Nat) a -&gt; Ordinal n -&gt; a #-}</span> <span></span> <a name="line-223"></a><span></span> <a name="line-224"></a><span class="hs-comment">-- | Flipped version of &#39;!!&#39;.</span> <span></span> <a name="line-225"></a><span class="hs-comment">--</span> <span></span> <a name="line-226"></a><span class="hs-comment">-- Since 0.1.0.0</span> <span></span> <a name="line-227"></a><span class="hs-identifier">index</span> <span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">ListLike</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636821"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636822"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636822"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">=&gt;</span> <span></span> <span class="hs-identifier hs-type">Int</span> <span></span> <span class="hs-glyph">-&gt;</span> <span></span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-type">Sized</span> </a><span></span> <a href="#local-1627636821"><span class="hs-identifier hs-type">f</span> </a><span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Succ</span> <span></span> <a href="#local-1627636823"><span class="hs-identifier hs-type">m</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636822"><span class="hs-identifier hs-type">a</span> </a><span></span> <span class="hs-glyph">-&gt;</span> <span></span> <a href="#local-1627636822"><span class="hs-identifier hs-type">a</span> </a><span></span> <a name="line-228"></a><a name="index"><a href="Data.Sized.html#index"><span class="hs-identifier">index</span> </a></a><span></span> <a name="local-1627636874"><a href="#local-1627636874"><span class="hs-identifier">n</span> </a></a><span></span> <span class="hs-special">(</span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-var">Sized</span> </a><span></span> <a name="local-1627636875"><a href="#local-1627636875"><span class="hs-identifier">xs</span> </a></a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">=</span> <span></span> <span class="hs-identifier hs-var">LL</span> <span class="hs-operator hs-var">.</span> <span class="hs-identifier hs-var">index</span> <span></span> <a href="#local-1627636875"><span class="hs-identifier hs-var">xs</span> </a><span></span> <a href="#local-1627636874"><span class="hs-identifier hs-var">n</span> </a><span></span> <a name="line-229"></a><span class="hs-pragma">{-# INLINE index #-}</span> <span></span> <a name="line-230"></a><span></span> <a name="line-231"></a><span class="hs-comment">-- | Flipped version of &#39;%!!&#39;.</span> <span></span> <a name="line-232"></a><span class="hs-comment">--</span> <span></span> <a name="line-233"></a><span class="hs-comment">-- Since 0.1.0.0</span> <span></span> <a name="line-234"></a><span class="hs-identifier">sIndex</span> <span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">HasOrdinal</span> <span></span> <a href="#local-1627636817"><span class="hs-identifier hs-type">nat</span> </a><span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">ListLike</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636818"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636819"><span class="hs-identifier hs-type">c</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636819"><span class="hs-identifier hs-type">c</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">=&gt;</span> <span></span> <span class="hs-identifier hs-type">Ordinal</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636820"><span class="hs-identifier hs-type">n</span> </a><span></span> <span class="hs-glyph">::</span> <span></span> <a href="#local-1627636817"><span class="hs-identifier hs-type">nat</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">-&gt;</span> <span></span> <a href="Data.Sized.Internal.html#Sized"><span class="hs-identifier hs-type">Sized</span> </a><span></span> <a href="#local-1627636818"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636820"><span class="hs-identifier hs-type">n</span> </a><span></span> <a href="#local-1627636819"><span class="hs-identifier hs-type">c</span> </a><span></span> <span class="hs-glyph">-&gt;</span> <span></span> <a href="#local-1627636819"><span class="hs-identifier hs-type">c</span> </a><span></span> <a name="line-235"></a><a name="sIndex"><a href="Data.Sized.html#sIndex"><span class="hs-identifier">sIndex</span> </a></a><span></span> <span class="hs-glyph">=</span> <span></span> <span class="hs-identifier hs-var">flip</span> <span></span> <span class="hs-special">(</span> <a href="Data.Sized.html#%25%21%21"><span class="hs-operator hs-var">%!!</span> </a><span class="hs-special">)</span> <span></span> <a name="line-236"></a><span class="hs-pragma">{-# INLINE sIndex #-}</span> <span></span> <a name="line-237"></a><span></span> <a name="line-238"></a><span class="hs-comment">-- | Take the first element of non-empty sequence.</span> <span></span> <a name="line-239"></a><span class="hs-comment">--   If you want to make case-analysis for general sequence,</span> <span></span> <a name="line-240"></a><span class="hs-comment">--   see  &lt;#ViewsAndPatterns Views and Patterns&gt; section.</span> <span></span> <a name="line-241"></a><span class="hs-comment">--</span> <span></span> <a name="line-242"></a><span class="hs-comment">-- Since 0.1.0.0</span> <span></span> <a name="line-243"></a><span class="hs-identifier">head</span> <span></span> <span class="hs-glyph">::</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">HasOrdinal</span> <span></span> <a href="#local-1627636811"><span class="hs-identifier hs-type">nat</span> </a><span class="hs-special">,</span> <span></span> <span class="hs-identifier hs-type">ListLike</span> <span></span> <span class="hs-special">(</span> <a href="#local-1627636812"><span class="hs-identifier hs-type">f</span> </a><span></span> <a href="#local-1627636813"><span class="hs-identifier hs-type">a</span> </a><span class="hs-special">)</span> <span></span> <a href="#local-1627636814"><span class="hs-identifier hs-type">b</span> </a><span class="hs-special">,</span> <span></span> <span class="hs-special">(</span> <span class="hs-identifier hs-type">Zero</span> <span></span> <a href="#local-1627636811"><span class="hs-identifier hs-type">nat</span> </a><span></span> <span class="hs-operator">:&lt;</span> <span></span> <a href="#local-1627636815"><span class="hs-identifier hs-type">n</span> </a><span class="hs-special">)</span> <span></span> <span class="hs-glyph">~</span> <span></span> <span class="hs-char">&#39;True) =&gt; Sized f n a -&gt; b
head = LL.head . runSized
{-# INLINE head #-}

-- | Take the last element of non-empty sequence.
--   If you want to make case-analysis for general sequence,
--   see  &lt;#ViewsAndPatterns Views and Patterns&gt; section.
--
-- Since 0.1.0.0
last :: (HasOrdinal nat, (Zero nat :&lt; n) ~ &#39;True, ListLike (f a) b) =&gt; Sized f n a -&gt; b
last = LL.last . runSized
{-# INLINE last #-}

-- | Take the &#39;head&#39; and &#39;tail&#39; of non-empty sequence.
--   If you want to make case-analysis for general sequence,
--   see  &lt;#ViewsAndPatterns Views and Patterns&gt; section.
--
-- Since 0.1.0.0
uncons :: ListLike (f a) b =&gt; Sized f (Succ n) a -&gt; (b, Sized f n a)
uncons = ((,) &lt;$&gt; LL.head &lt;*&gt; Sized . LL.tail) . runSized
{-# INLINE [1] uncons #-}
{-# RULES
&quot;uncons/[]&quot; [~1] forall (x :: a) (xs:: [a]).
  uncons (Sized (x : xs)) = (x, Sized xs)
&quot;uncons/Seq&quot; [~1] forall (xs:: Seq.Seq a).
  uncons (Sized xs) =
    case Seq.viewl xs of { (x Seq.:&lt; ys) -&gt; (x, Sized ys)
                         ; _ -&gt; P.error &quot;Empty seq with non-zero index!&quot;
                         }
  #-}

uncons&#39; :: ListLike (f a) b =&gt; proxy n -&gt; Sized f (Succ n) a -&gt; (b, Sized f n a)
uncons&#39; _  = uncons
{-# INLINE uncons&#39; #-}

-- | Take the &#39;init&#39; and &#39;last&#39; of non-empty sequence.
--   If you want to make case-analysis for general sequence,
--   see  &lt;#ViewsAndPatterns Views and Patterns&gt; section.
--
-- Since 0.1.0.0
unsnoc :: ListLike (f a) b =&gt; Sized f (Succ n) a -&gt; (Sized f n a, b)
unsnoc = ((,) &lt;$&gt; Sized . LL.init &lt;*&gt; LL.last) . runSized
{-# NOINLINE [1] unsnoc #-}
{-# RULES
&quot;unsnoc/Seq&quot; [~1] forall (xs:: Seq.Seq a).
  unsnoc (Sized xs) =
    case Seq.viewr xs of { (ys Seq.:&gt; x) -&gt; (Sized ys, x)
                         ; _ -&gt; P.error &quot;Empty seq with non-zero index!&quot;
                         }
  #-}

unsnoc&#39; :: ListLike (f a) b =&gt; proxy n -&gt; Sized f (Succ n) a -&gt; (Sized f n a, b)
unsnoc&#39; _  = unsnoc
{-# INLINE unsnoc&#39; #-}


--------------------------------------------------------------------------------
--- Slicing
--------------------------------------------------------------------------------

-- | Take the tail of non-empty sequence.
--   If you want to make case-analysis for general sequence,
--   see  &lt;#ViewsAndPatterns Views and Patterns&gt; section.
--
-- Since 0.1.0.0
tail :: (HasOrdinal nat, ListLike (f a) a)=&gt; Sized f (Succ n) a -&gt; Sized f (n :: nat) a
tail = Sized . LL.tail . runSized
{-# INLINE tail #-}

-- | Take the initial segment of non-empty sequence.
--   If you want to make case-analysis for general sequence,
--   see  &lt;#ViewsAndPatterns Views and Patterns&gt; section.
--
-- Since 0.1.0.0
init :: ListLike (f a) a =&gt; Sized f (Succ n) a -&gt; Sized f n a
init = Sized . LL.init . runSized
{-# INLINE init #-}

-- | @take k xs@ takes first @k@ element of @xs@ where
-- the length of @xs@ should be larger than @k@.
-- It is really sad, that this function
-- takes at least O(k) regardless of base container.
--
-- Since 0.1.0.0
take :: (ListLike (f a) a, (n :&lt;= m) ~ &#39;True, HasOrdinal nat)
     =&gt; Sing (n :: nat) -&gt; Sized f m a -&gt; Sized f n a
take sn = Sized . LL.genericTake (demote&#39; sn) . runSized
{-# INLINE take #-}

-- | @take k xs@ takes first @k@ element of @xs@ at most.
-- It is really sad, that this function
-- takes at least O(k) regardless of base container.
--
-- Since 0.1.0.0
takeAtMost :: (ListLike (f a) a, HasOrdinal nat)
           =&gt; Sing (n :: nat) -&gt; Sized f m a -&gt; Sized f (Min n m) a
takeAtMost sn = Sized . LL.genericTake (demote $ Monomorphic sn) . runSized
{-# INLINE takeAtMost #-}

-- | @drop k xs@ drops first @k@ element of @xs@ and returns
-- the rest of sequence, where the length of @xs@ should be larger than @k@.
-- It is really sad, that this function
-- takes at least O(k) regardless of base container.
--
-- Since 0.1.0.0
drop :: (HasOrdinal nat, ListLike (f a) a, (n :&lt;= m) ~ &#39;True)
     =&gt; Sing (n :: nat) -&gt; Sized f m a -&gt; Sized f (m :- n) a
drop sn = Sized . LL.genericDrop (demote&#39; sn) . runSized
{-# INLINE drop #-}

-- | @splitAt k xs@ split @xs@ at @k@, where
-- the length of @xs@ should be less than or equal to @k@.
-- It is really sad, that this function
-- takes at least O(k) regardless of base container.
--
-- Since 0.1.0.0
splitAt :: (ListLike (f a) a , (n :&lt;= m) ~ &#39;True, HasOrdinal nat)
        =&gt; Sing (n :: nat) -&gt; Sized f m a -&gt; (Sized f n a, Sized f (m :-. n) a)
splitAt n (Sized xs) =
  let (as, bs) = LL.genericSplitAt (demote&#39; n) xs
  in (Sized as, Sized bs)
{-# INLINE splitAt #-}

-- | @splitAtMost k xs@ split @xs@ at @k@.
--   If @k@ exceeds the length of @xs@, then the second result value become empty.
-- It is really sad, that this function
-- takes at least O(k) regardless of base container.
--
-- Since 0.1.0.0
splitAtMost :: (HasOrdinal nat, ListLike (f a) a)
            =&gt; Sing (n :: nat) -&gt; Sized f m a -&gt; (Sized f (Min n m) a, Sized f (m :-. n) a)
splitAtMost n (Sized xs) =
  let (as, bs) = LL.genericSplitAt (demote&#39; n) xs
  in (Sized as, Sized bs)
{-# INLINE splitAtMost #-}


--------------------------------------------------------------------------------
-- Construction
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- Initialisation
--------------------------------------------------------------------------------

-- | Empty sequence.
--
-- Since 0.1.0.0
empty :: forall f a. (HasOrdinal nat, ListLike (f a) a) =&gt; Sized f (Zero nat :: nat) a
empty = Sized LL.empty
{-# INLINE empty #-}

-- | Sequence with one element.
--
-- Since 0.1.0.0
singleton :: forall f a. ListLike (f a) a =&gt; a -&gt; Sized f 1 a
singleton = Sized . LL.singleton
{-# INLINE singleton #-}

-- | Consruct the &#39;Sized&#39; sequence from base type, but
--   the length parameter is dynamically determined and
--   existentially quantified; see also &#39;SomeSized&#39;.
--
-- Since 0.1.0.0
toSomeSized :: forall nat f a. (HasOrdinal nat, ListLike (f a) a)
            =&gt; f a -&gt; SomeSized f nat a
toSomeSized = \xs -&gt;
  case promote $ LL.genericLength xs of
    Monomorphic sn -&gt; withSingI sn $ SomeSized sn $ unsafeToSized sn xs

-- | Replicates the same value.
--
-- Since 0.1.0.0
replicate :: forall f (n :: nat) a. (HasOrdinal nat, ListLike (f a) a)
          =&gt; Sing n -&gt; a -&gt; Sized f n a
replicate sn a = Sized $ LL.genericReplicate (demote $ Monomorphic sn) a
{-# INLINE replicate #-}

-- | &#39;replicate&#39; with the length inferred.
--
-- Since 0.1.0.0
replicate&#39; :: (HasOrdinal nat, SingI (n :: nat), ListLike (f a) a) =&gt; a -&gt; Sized f n a
replicate&#39; = withSing replicate
{-# INLINE replicate&#39; #-}

generate :: forall (nat :: Type) (n :: nat) (a :: Type) f.
            (ListLike (f a) a, HasOrdinal nat)
         =&gt; Sing n -&gt; (Ordinal n -&gt; a) -&gt; Sized f n a
generate n f = unsafeFromList n [f i | i &lt;- enumOrdinal n ]
{-# INLINE [1] generate #-}
{-# RULES
&quot;generate/Vector&quot; [~1] forall (n :: (HasOrdinal nat) =&gt; Sing (n :: nat)) (f :: Ordinal n -&gt; a).
  generate (n :: Sing (n :: (nat :: Type))) f = withSingI n $ Sized (V.generate (fromSing&#39; n) (f . toEnum))
&quot;generate/SVector&quot; [~1] forall (n :: HasOrdinal nat =&gt; Sing (n :: nat))
                       (f :: SV.Storable a =&gt; Ordinal n -&gt; a).
  generate n f = withSingI n $ Sized (SV.generate (fromSing&#39; n) (f . toEnum))
&quot;generate/SVector&quot; [~1] forall (n :: HasOrdinal nat =&gt; Sing (n :: nat))
                       (f :: UV.Unbox a =&gt; Ordinal n -&gt; a).
  generate n f = withSingI n $ Sized (UV.generate (fromSing&#39; n) (f . toEnum))
&quot;generate/Seq&quot; [~1] forall (n :: HasOrdinal nat =&gt; Sing (n :: nat))
                       (f :: Ordinal n -&gt; a).
  generate n f = withSingI n $ Sized (Seq.fromFunction (fromSing&#39; n) (f . toEnum))
#-}

fromSing&#39; :: HasOrdinal nat =&gt; Sing (n :: nat) -&gt; Int
fromSing&#39; = P.fromIntegral . demote . Monomorphic

--------------------------------------------------------------------------------
--- Concatenation
--------------------------------------------------------------------------------

-- | Append an element to the head of sequence.
--
-- Since 0.1.0.0
cons :: (ListLike (f a) b) =&gt; b -&gt; Sized f n a -&gt; Sized f (Succ n) a
cons a = Sized . LL.cons a . runSized
{-# INLINE cons #-}

-- | Infix version of &#39;cons&#39;.
--
-- Since 0.1.0.0
(&lt;|) :: (ListLike (f a) b) =&gt; b -&gt; Sized f n a -&gt; Sized f (Succ n) a
(&lt;|) = cons
{-# INLINE (&lt;|) #-}
infixr 5 &lt;|

-- | Append an element to the tail of sequence.
--
-- Since 0.1.0.0
snoc :: (ListLike (f a) b) =&gt; Sized f n a -&gt; b -&gt; Sized f (Succ n) a
snoc (Sized xs) a = Sized $ LL.snoc xs a
{-# INLINE snoc #-}

-- | Infix version of &#39;snoc&#39;.
--
-- Since 0.1.0.0
(|&gt;) :: (ListLike (f a) b) =&gt; Sized f n a -&gt; b -&gt; Sized f (Succ n) a
(|&gt;) = snoc
{-# INLINE (|&gt;) #-}
infixl 5 |&gt;

-- | Append two lists.
--
-- Since 0.1.0.0
append :: ListLike (f a) a =&gt; Sized f n a -&gt; Sized f m a -&gt; Sized f (n :+ m) a
append (Sized xs) (Sized ys) = Sized $ LL.append xs ys
{-# INLINE append #-}

-- | Infix version of &#39;append&#39;.
--
-- Since 0.1.0.0
(++) :: (ListLike (f a) a) =&gt; Sized f n a -&gt; Sized f m a -&gt; Sized f (n :+ m) a
(++) = append
infixr 5 ++

-- | Concatenates multiple sequences into one.
--
-- Since 0.1.0.0
concat :: forall f f&#39; m n a. (Functor f&#39;, Foldable f&#39;, ListLike (f a) a)
       =&gt; Sized f&#39; m (Sized f n a) -&gt; Sized f (m :* n) a
concat =  Sized . F.foldr LL.append LL.empty . P.fmap runSized
{-# INLINE [2] concat #-}

{-# RULES
&quot;concat/list-list&quot; [~1] forall (xss :: [Sized [] n a]).
  concat (Sized xss) = Sized (L.concatMap runSized xss)
&quot;concat/list-list&quot; [~2] forall (xss :: (ListLike (f a) a, ListLike (f (Sized f n a)) (Sized f n a))
                                   =&gt; f (Sized f n a)).
  concat (Sized xss) = Sized (LL.concatMap runSized xss)
  #-}

--------------------------------------------------------------------------------
--- Zips
--------------------------------------------------------------------------------

-- | Zipping two sequences. Length is adjusted to shorter one.
--
-- Since 0.1.0.0
zip :: (ListLike (f a) a, ListLike (f b) b, ListLike (f (a, b)) (a, b))
    =&gt; Sized f n a -&gt; Sized f m b -&gt; Sized f (Min n m) (a, b)
zip (Sized xs) (Sized ys) = Sized $ LL.zip xs ys
{-# INLINE [1] zip #-}
{-# RULES
&quot;zip/Seq&quot; [~1] forall xs ys.
  zip (Sized xs) (Sized ys) = Sized (Seq.zip xs ys)
&quot;zip/List&quot; [~1] forall xs ys.
  zip (Sized xs) (Sized ys) = Sized (P.zip xs ys)
&quot;zip/Vector&quot; [~1] forall xs ys.
  zip (Sized xs) (Sized ys) = Sized (V.zip xs ys)
&quot;zip/UVector&quot; [~1]
  forall (xs :: UV.Unbox a =&gt; UV.Vector a) (ys :: UV.Unbox b =&gt; UV.Vector b).
  zip (Sized xs) (Sized ys) = Sized (UV.zip xs ys)
  #-}

-- | &#39;zip&#39; for the sequences of the same length.
--
-- Since 0.1.0.0
zipSame :: (ListLike (f a) a, ListLike (f b) b, ListLike (f (a, b)) (a, b))
        =&gt; Sized f n a -&gt; Sized f n b -&gt; Sized f n (a, b)
zipSame (Sized xs) (Sized ys) = Sized $ LL.zip xs ys
{-# INLINE [1] zipSame #-}
{-# RULES
&quot;zipSame/Seq&quot; [~1] forall xs ys.
  zipSame (Sized xs) (Sized ys) = Sized (Seq.zip xs ys)
&quot;zipSame/List&quot; [~1] forall xs ys.
  zipSame (Sized xs) (Sized ys) = Sized (P.zip xs ys)
&quot;zipSame/Vector&quot; [~1] forall xs ys.
  zipSame (Sized xs) (Sized ys) = Sized (V.zip xs ys)
&quot;zipSame/UVector&quot; [~1]
  forall (xs :: UV.Unbox a =&gt; UV.Vector a) (ys :: UV.Unbox b =&gt; UV.Vector b).
  zipSame (Sized xs) (Sized ys) = Sized (UV.zip xs ys)
  #-}

-- | Zipping two sequences with funtion. Length is adjusted to shorter one.
--
-- Since 0.1.0.0
zipWith :: (ListLike (f a) a, ListLike (f b) b, ListLike (f c) c)
    =&gt; (a -&gt; b -&gt; c) -&gt; Sized f n a -&gt; Sized f m b -&gt; Sized f (Min n m) c
zipWith f (Sized xs) (Sized ys) = Sized $ LL.zipWith f xs ys
{-# INLINE [1] zipWith #-}

{-# RULES
&quot;zipWith/Seq&quot; [~1] forall f xs ys.
  zipWith f (Sized xs) (Sized ys) = Sized (Seq.zipWith f xs ys)
&quot;zipWith/List&quot; [~1] forall f xs ys.
  zipWith f (Sized xs) (Sized ys) = Sized (P.zipWith f xs ys)
&quot;zipWith/Vector&quot; [~1] forall f xs ys.
  zipWith f (Sized xs) (Sized ys) = Sized (V.zipWith f xs ys)
&quot;zipWith/UVector&quot; [~1]
  forall (f :: (UV.Unbox a, UV.Unbox b, UV.Unbox c) =&gt; a -&gt; b -&gt; c)
    xs ys.
  zipWith f (Sized xs) (Sized ys) = Sized (UV.zipWith f xs ys)
&quot;zipWith/MVector&quot; [~1]
  forall (f :: (SV.Storable a, SV.Storable b, SV.Storable c) =&gt; a -&gt; b -&gt; c)
    xs ys.
  zipWith f (Sized xs) (Sized ys) = Sized (SV.zipWith f xs ys)
  #-}

-- | &#39;zipWith&#39; for the sequences of the same length.
--
-- Since 0.1.0.0
zipWithSame :: (ListLike (f a) a, ListLike (f b) b, ListLike (f c) c)
            =&gt; (a -&gt; b -&gt; c) -&gt; Sized f n a -&gt; Sized f n b -&gt; Sized f n c
zipWithSame f (Sized xs) (Sized ys) = Sized $ LL.zipWith f xs ys
{-# INLINE [1] zipWithSame #-}

{-# RULES
&quot;zipWithSame/Seq&quot; [~1] forall f xs ys.
  zipWithSame f (Sized xs) (Sized ys) = Sized (Seq.zipWith f xs ys)
&quot;zipWithSame/List&quot; [~1] forall f xs ys.
  zipWithSame f (Sized xs) (Sized ys) = Sized (P.zipWith f xs ys)
&quot;zipWithSame/Vector&quot; [~1] forall f xs ys.
  zipWithSame f (Sized xs) (Sized ys) = Sized (V.zipWith f xs ys)
&quot;zipWithSame/UVector&quot; [~1]
  forall (f :: (UV.Unbox a, UV.Unbox b, UV.Unbox c) =&gt; a -&gt; b -&gt; c)
    xs ys.
  zipWithSame f (Sized xs) (Sized ys) = Sized (UV.zipWith f xs ys)
&quot;zipWithSame/MVector&quot; [~1]
  forall (f :: (SV.Storable a, SV.Storable b, SV.Storable c) =&gt; a -&gt; b -&gt; c)
    xs ys.
  zipWithSame f (Sized xs) (Sized ys) = Sized (SV.zipWith f xs ys)
  #-}

-- | Unzipping the sequence of tuples.
--
-- Since 0.1.0.0
unzip :: (ListLike (f a) a, ListLike (f b) b, ListLike (f (a, b)) (a,b))
      =&gt; Sized f n (a, b) -&gt; (Sized f n a, Sized f n b)
unzip (Sized xys) =
  let (xs, ys) = LL.unzip xys
  in (Sized xs, Sized ys)
{-# INLINE unzip #-}


--------------------------------------------------------------------------------
-- Transformation
--------------------------------------------------------------------------------

-- | Map function.
--
-- Since 0.1.0.0
map :: (ListLike (f a) a, ListLike (f b) b) =&gt; (a -&gt; b) -&gt; Sized f n a -&gt; Sized f n b
map f = Sized . LL.map f . runSized
{-# INLINE map #-}

fmap :: forall f n a b. Functor f =&gt; (a -&gt; b) -&gt; Sized f n a -&gt; Sized f n b
fmap f = Sized . P.fmap f . runSized
{-# INLINE fmap #-}

-- | Reverse function.
--
-- Since 0.1.0.0
reverse :: ListLike (f a) a =&gt; Sized f n a -&gt; Sized f n a
reverse = Sized .  LL.reverse . runSized
{-# INLINE reverse #-}

-- | Intersperces.
--
-- Since 0.1.0.0
intersperse :: ListLike (f a) a =&gt; a -&gt; Sized f n a -&gt; Sized f ((FromInteger 2 :* n) :-. 1) a
intersperse a = Sized . LL.intersperse a . runSized
{-# INLINE intersperse #-}

-- | Remove all duplicates.
--
-- Since 0.1.0.0
nub :: (HasOrdinal nat, ListLike (f a) a, Eq a) =&gt; Sized f n a -&gt; SomeSized f nat a
nub = toSomeSized . LL.nub . runSized

-- | Sorting sequence by ascending order.
--
-- Since 0.1.0.0
sort :: (ListLike (f a) a, Ord a)
     =&gt; Sized f n a -&gt; Sized f n a
sort = Sized . LL.sort . runSized

-- | Generalized version of &#39;sort&#39;.
--
-- Since 0.1.0.0
sortBy :: (ListLike (f a) a) =&gt; (a -&gt; a -&gt; Ordering) -&gt; Sized f n a -&gt; Sized f n a
sortBy cmp = Sized . LL.sortBy cmp . runSized

-- | Insert new element into the presorted sequence.
--
-- Since 0.1.0.0
insert :: (ListLike (f a) a, Ord a) =&gt; a -&gt; Sized f n a -&gt; Sized f (Succ n) a
insert a = Sized . LL.insert a . runSized

-- | Generalized version of &#39;insert&#39;.
--
-- Since 0.1.0.0
insertBy :: (ListLike (f a) a) =&gt; (a -&gt; a -&gt; Ordering) -&gt; a -&gt; Sized f n a -&gt; Sized f (Succ n) a
insertBy cmp a = Sized . LL.insertBy cmp a . runSized


--------------------------------------------------------------------------------
-- Conversion
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- List
--------------------------------------------------------------------------------

-- | Convert to list.
--
-- Since 0.1.0.0
toList :: ListLike (f a) a =&gt; Sized f n a -&gt; [a]
toList = LL.toList . runSized
{-# INLINE [2] toList #-}

{-# RULES
&quot;toList/&quot; forall (xs :: Sized [] a n).
  Data.Sized.toList xs = runSized xs
  #-}

-- | If the given list is shorter than @n@, then returns @Nothing@
--   Otherwise returns @Sized f n a@ consisting of initial @n@ element
--   of given list.
--
-- Since 0.1.0.0
fromList :: forall f n a. (HasOrdinal nat, ListLike (f a) a)
         =&gt; Sing (n :: nat) -&gt; [a] -&gt; Maybe (Sized f n a)
fromList Zero _ = Just $ Sized (LL.empty :: f a)
fromList sn xs =
  let len = P.fromIntegral $ demote $ Monomorphic sn
  in if P.length xs &lt; len
     then Nothing
     else Just $ unsafeFromList sn $ P.take len xs
{-# INLINABLE [2] fromList #-}

-- | &#39;fromList&#39; with the result length inferred.
--
-- Since 0.1.0.0
fromList&#39; :: (ListLike (f a) a, SingI (n :: TL.Nat)) =&gt; [a] -&gt; Maybe (Sized f n a)
fromList&#39; = withSing fromList
{-# INLINE fromList&#39; #-}

-- | Unsafe version of &#39;fromList&#39;. If the length of the given list does not
--   equal to @n@, then something unusual happens.
--
-- Since 0.1.0.0
unsafeFromList :: forall (nat :: Type) f (n :: nat) a. ListLike (f a) a =&gt; Sing n -&gt; [a] -&gt; Sized f n a
unsafeFromList _ xs = Sized $ LL.fromList xs
{-# INLINE [1] unsafeFromList #-}
{-# RULES
&quot;unsafeFromList/List&quot; [~1] forall s xs.
  unsafeFromList s  xs = Sized xs
&quot;unsafeFromList/Vector&quot; [~1] forall s (xs :: [a]).
  unsafeFromList s  xs = Sized (V.fromList xs)
&quot;unsafeFromList/Seq&quot; [~1] forall s (xs :: [a]).
  unsafeFromList s  xs = Sized (Seq.fromList xs)
&quot;unsafeFromList/SVector&quot; [~1] forall s (xs :: SV.Storable a =&gt; [a]).
  unsafeFromList s  xs = Sized (SV.fromList xs)
&quot;unsafeFromList/UVector&quot; [~1] forall s (xs :: UV.Unbox a =&gt; [a]).
  unsafeFromList s  xs = Sized (UV.fromList xs)
  #-}

-- | &#39;unsafeFromList&#39; with the result length inferred.
--
-- Since 0.1.0.0
unsafeFromList&#39; :: (SingI (n :: TL.Nat), ListLike (f a) a) =&gt; [a] -&gt; Sized f n a
unsafeFromList&#39; = withSing unsafeFromList
{-# INLINE [1] unsafeFromList&#39; #-}
{-# RULES
&quot;unsafeFromList&#39;/List&quot; [~1] forall xs.
  unsafeFromList&#39;  xs = Sized xs
&quot;unsafeFromList&#39;/Vector&quot; [~1] forall (xs :: [a]).
  unsafeFromList&#39;  xs = Sized (V.fromList xs)
&quot;unsafeFromList&#39;/Seq&quot; [~1] forall (xs :: [a]).
  unsafeFromList&#39;  xs = Sized (Seq.fromList xs)
&quot;unsafeFromList&#39;/SVector&quot; [~1] forall (xs :: SV.Storable a =&gt; [a]).
  unsafeFromList&#39;  xs = Sized (SV.fromList xs)
&quot;unsafeFromList&#39;/UVector&quot; [~1] forall (xs :: UV.Unbox a =&gt; [a]).
  unsafeFromList&#39;  xs = Sized (UV.fromList xs)
  #-}


-- | Construct a @Sized f n a@ by padding default value if the given list is short.
--
-- Since 0.1.0.0
fromListWithDefault :: forall f (n :: nat) a. (HasOrdinal nat, ListLike (f a) a)
                    =&gt; Sing n -&gt; a -&gt; [a] -&gt; Sized f n a
fromListWithDefault sn def xs =
  let len = demote&#39; sn
  in Sized $ LL.fromList (L.genericTake len xs) `LL.append` LL.genericReplicate (len - L.genericLength xs) def
{-# INLINABLE fromListWithDefault #-}

-- | &#39;fromListWithDefault&#39; with the result length inferred.
--
-- Since 0.1.0.0
fromListWithDefault&#39; :: (SingI (n :: TL.Nat), ListLike (f a) a) =&gt; a -&gt; [a] -&gt; Sized f n a
fromListWithDefault&#39; = withSing fromListWithDefault
{-# INLINE fromListWithDefault&#39; #-}

--------------------------------------------------------------------------------
--- Base containes
--------------------------------------------------------------------------------

-- | Forget the length and obtain the wrapped base container.
--
-- Since 0.1.0.0
unsized :: Sized f n a -&gt; f a
unsized = runSized
{-# INLINE unsized #-}

-- | If the length of the input is shorter than @n@, then returns @Nothing@.
--   Otherwise returns @Sized f n a@ consisting of initial @n@ element
--   of the input.
--
-- Since 0.1.0.0
toSized :: (HasOrdinal nat, ListLike (f a) a)
        =&gt; Sing (n :: nat) -&gt; f a -&gt; Maybe (Sized f n a)
toSized sn xs =
  let len = demote&#39; sn
  in if LL.genericLength xs &lt; len
     then Nothing
     else Just $ unsafeToSized sn $ LL.genericTake len xs
{-# INLINABLE [2] toSized #-}

-- | &#39;toSized&#39; with the result length inferred.
--
-- Since 0.1.0.0
toSized&#39; :: (ListLike (f a) a, SingI (n :: TL.Nat)) =&gt; f a -&gt; Maybe (Sized f n a)
toSized&#39; = withSing toSized
{-# INLINE toSized&#39; #-}

-- | Unsafe version of &#39;toSized&#39;. If the length of the given list does not
--   equal to @n@, then something unusual happens.
--
-- Since 0.1.0.0
unsafeToSized :: Sing n -&gt; f a -&gt; Sized f n a
unsafeToSized _ = Sized
{-# INLINE [2] unsafeToSized #-}

-- | &#39;unsafeToSized&#39; with the result length inferred.
--
-- Since 0.1.0.0
unsafeToSized&#39; :: (SingI (n :: TL.Nat), ListLike (f a) a) =&gt; f a -&gt; Sized f n a
unsafeToSized&#39; = withSing unsafeToSized
{-# INLINE unsafeToSized&#39; #-}

-- | Construct a @Sized f n a@ by padding default value if the given list is short.
--
-- Since 0.1.0.0
toSizedWithDefault :: (HasOrdinal nat, ListLike (f a) a)
                   =&gt; Sing (n :: nat) -&gt; a -&gt; f a -&gt; Sized f n a
toSizedWithDefault sn def xs =
  let len = P.fromIntegral $ demote (Monomorphic sn)
  in Sized $ LL.take len xs `LL.append` LL.replicate (len - LL.length xs) def
{-# INLINABLE toSizedWithDefault #-}

-- | &#39;toSizedWithDefault&#39; with the result length inferred.
--
-- Since 0.1.0.0
toSizedWithDefault&#39; :: (SingI (n :: TL.Nat), ListLike (f a) a) =&gt; a -&gt; f a -&gt; Sized f n a
toSizedWithDefault&#39; = withSing toSizedWithDefault
{-# INLINE toSizedWithDefault&#39; #-}


--------------------------------------------------------------------------------
-- Querying
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- Partitioning
--------------------------------------------------------------------------------

-- | The type @Partitioned f n a@ represents partitioned sequence of length @n@.
--   Value @Partitioned lenL ls lenR rs@ stands for:
--
--   * Entire sequence is divided into @ls@ and @rs@, and their length
--     are @lenL@ and @lenR@ resp.
--
--   * @lenL + lenR = n@
--
-- Since 0.1.0.0
data Partitioned f n a where
  Partitioned :: (ListLike (f a) a)
              =&gt; Sing n
              -&gt; Sized f (n :: TL.Nat) a
              -&gt; Sing m
              -&gt; Sized f (m :: TL.Nat) a
              -&gt; Partitioned f (n :+ m) a

-- | Take the initial segment as long as elements satisfys the predicate.
--
-- Since 0.1.0.0
takeWhile :: (HasOrdinal nat, ListLike (f a) a)
          =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; SomeSized f nat a
takeWhile p = toSomeSized . LL.takeWhile p . runSized
{-# INLINE takeWhile #-}

-- | Drop the initial segment as long as elements satisfys the predicate.
--
-- Since 0.1.0.0
dropWhile :: (HasOrdinal nat, ListLike (f a) a)
          =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; SomeSized f nat a
dropWhile p = toSomeSized . LL.dropWhile p . runSized
{-# INLINE dropWhile #-}

-- | Invariant: @&#39;ListLike&#39; (f a) a@ instance must be implemented
-- to satisfy the following property:
-- @length (fst (span p xs)) + length (snd (span p xs)) == length xs@
-- Otherwise, this function introduces severe contradiction.
--
-- Since 0.1.0.0
span :: ListLike (f a) a
     =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; Partitioned f n a
span p xs =
  let (as, bs) = LL.span p $ runSized xs
  in case (toSomeSized as, toSomeSized bs) of
    (SomeSized lenL ls, SomeSized lenR rs) -&gt;
      unsafeCoerce $ Partitioned lenL ls lenR rs
{-# INLINE span #-}

-- | Invariant: @&#39;ListLike&#39; (f a) a@ instance must be implemented
-- to satisfy the following property:
-- @length (fst (break p xs)) + length (snd (break p xs)) == length xs@
-- Otherwise, this function introduces severe contradiction.
--
-- Since 0.1.0.0
break :: ListLike (f a) a
     =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; Partitioned f n a
break p (Sized xs) =
  let (as, bs) = LL.break p xs
  in case (toSomeSized as, toSomeSized bs) of
    (SomeSized lenL ls, SomeSized lenR rs) -&gt;
      unsafeCoerce $ Partitioned lenL ls lenR rs
{-# INLINE break #-}

-- | Invariant: @&#39;ListLike&#39; (f a) a@ instance must be implemented
-- to satisfy the following property:
-- @length (fst (partition p xs)) + length (snd (partition p xs)) == length xs@
-- Otherwise, this function introduces severe contradiction.
--
-- Since 0.1.0.0
partition :: ListLike (f a) a
     =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; Partitioned f n a
partition p (Sized xs) =
         let (as, bs) = LL.partition p xs
         in case (toSomeSized as, toSomeSized bs) of
           (SomeSized lenL ls, SomeSized lenR rs) -&gt;
             unsafeCoerce $ Partitioned lenL ls lenR rs
{-# INLINE partition #-}

--------------------------------------------------------------------------------
--- Searching
--------------------------------------------------------------------------------
-- | Membership test; see also &#39;notElem&#39;.
--
-- Since 0.1.0.0
elem :: (ListLike (f a) a, Eq a) =&gt; a -&gt; Sized f n a -&gt; Bool
elem a = LL.elem a . runSized
{-# INLINE elem #-}

-- | Negation of &#39;elem&#39;.
--
-- Since 0.1.0.0
notElem :: (ListLike (f a) a, Eq a) =&gt; a -&gt; Sized f n a -&gt; Bool
notElem a = LL.notElem a . runSized
{-# INLINE notElem #-}

-- | Find the element satisfying the predicate.
--
-- Since 0.1.0.0
find :: Foldable f =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; Maybe a
find p = F.find p
{-# INLINE[1] find #-}
{-# RULES
&quot;find/List&quot; [~1] forall p (xs :: [a]).
  find p (Sized xs) = L.find p xs
&quot;find/Vector&quot; [~1] forall p xs.
  find p (Sized xs) = V.find p xs
&quot;find/Storable Vector&quot; [~1] forall p (xs :: SV.Storable a =&gt; SV.Vector a).
  find p (Sized xs) = SV.find p xs
&quot;find/Unboxed Vector&quot; [~1] forall p (xs :: UV.Unbox a =&gt; UV.Vector a).
  find p (Sized xs) = UV.find p xs
  #-}

-- | @&#39;Foldable&#39;@ version of @&#39;find&#39;@.
findF :: (Foldable f) =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; Maybe a
findF p = getFirst. F.foldMap (\a -&gt; if p a then First (Just a) else First Nothing) . runSized
{-# INLINE [1] findF #-}
{-# SPECIALISE [0] findF :: (a -&gt; Bool) -&gt; Sized Seq.Seq n a -&gt; Maybe a #-}
{-# RULES
&quot;findF/list&quot; [~1] forall p.
  findF p = L.find p
  #-}

-- | @&#39;findIndex&#39; p xs@ find the element satisfying @p@ and returns its index if exists.
--
-- Since 0.1.0.0
findIndex :: ListLike (f a) a =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; Maybe Int
findIndex p = LL.findIndex p . runSized
{-# INLINE findIndex #-}

-- | &#39;Ordinal&#39; version of &#39;findIndex&#39;.
--
-- Since 0.1.0.0
sFindIndex :: (SingI (n :: nat), ListLike (f a) a, HasOrdinal nat)
           =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; Maybe (Ordinal n)
sFindIndex p = P.fmap toEnum . findIndex p
{-# INLINE sFindIndex #-}

-- | @&#39;findIndex&#39;@ implemented in terms of @&#39;FoldableWithIndex&#39;@
findIndexIF :: (FoldableWithIndex i f) =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; Maybe i
findIndexIF p = P.fmap fst . ifind (P.const p) . runSized
{-# INLINE [1] findIndexIF #-}
{-# RULES
&quot;findIndexIF/list&quot; [~1] forall p.
  findIndexIF p = L.findIndex p . runSized
&quot;findIndexIF/vector&quot; [~1] forall p.
  findIndexIF p = V.findIndex p . runSized
  #-}

-- | @&#39;sFindIndex&#39;@ implemented in terms of @&#39;FoldableWithIndex&#39;@
sFindIndexIF :: (FoldableWithIndex i f, P.Integral i, HasOrdinal nat, SingI n)
             =&gt; (a -&gt; Bool) -&gt; Sized f (n :: nat) a -&gt; Maybe (Ordinal n)
sFindIndexIF p = P.fmap fst . ifind (P.const p)
{-# INLINE [1] sFindIndexIF #-}
-- {-# RULES
-- &quot;sFindIndexIF/list&quot; [~1] forall p .
--   sFindIndexIF p = P.fmap toEnum . L.findIndex p . runSized
-- &quot;sFindIndexIF/vector&quot; [~1] forall p.
--   sFindIndexIF p = P.fmap toEnum . V.findIndex p . runSized
--   #-}

-- | @&#39;findIndices&#39; p xs@ find all elements satisfying @p@ and returns their indices.
--
-- Since 0.1.0.0
findIndices :: ListLike (f a) a =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; [Int]
findIndices p = LL.findIndices p . runSized
{-# INLINE findIndices #-}
{-# SPECIALISE findIndices :: (a -&gt; Bool) -&gt; Sized [] n a -&gt; [Int] #-}

-- | @&#39;findIndices&#39;@ implemented in terms of @&#39;FoldableWithIndex&#39;@
findIndicesIF :: (FoldableWithIndex i f) =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; [i]
findIndicesIF p = flip appEndo [] . ifoldMap (\i x -&gt; if p x then Endo (i:) else Endo P.id) . runSized
{-# INLINE [1] findIndicesIF #-}
{-# RULES
&quot;findIndicesIF/list&quot; [~1] forall p.
  findIndicesIF p = L.findIndices p . runSized
&quot;findIndicesIF/vector&quot; [~1] forall p.
  findIndicesIF p = V.toList . V.findIndices p . runSized
  #-}


-- | &#39;Ordinal&#39; version of &#39;findIndices&#39;.
--
-- Since 0.1.0.0
sFindIndices :: (HasOrdinal nat, SingI (n :: nat), ListLike (f a) a)
             =&gt; (a -&gt; Bool) -&gt; Sized f n a -&gt; [Ordinal n]
sFindIndices p = P.fmap (toEnum . P.fromIntegral) . findIndices p
{-# INLINE sFindIndices #-}

sFindIndicesIF :: (FoldableWithIndex i f, P.Integral i, HasOrdinal nat, SingI n)
               =&gt; (a -&gt; Bool) -&gt; Sized f (n :: nat) a -&gt; [Ordinal n]
sFindIndicesIF p = flip appEndo [] .
                   ifoldMap (\i x -&gt; if p x then Endo (P.toEnum (P.fromIntegral i):) else Endo P.id) .
                   runSized
{-# INLINE [1] sFindIndicesIF #-}
-- {-# RULES
-- &quot;sFindIndicesIF/list&quot; [~1] forall p.
--   sFindIndicesIF p = P.map toEnum . L.findIndices p . runSized
-- &quot;sFindIndicesIF/vector&quot; [~1] forall p.
--   sFindIndicesIF p = V.toList . V.map toEnum . V.findIndices p . runSized
--   #-}

{-# RULES
&quot;Foldable.sum/Vector&quot;
  F.sum = V.sum . runSized
&quot;MonoTraversable.sum/Vector&quot;
  MT.osum = V.sum . runSized
  #-}

-- | Returns the index of the given element in the list, if exists.
--
-- Since 0.1.0.0
elemIndex :: (Eq a, ListLike (f a) a) =&gt; a -&gt; Sized f n a -&gt; Maybe Int
elemIndex a (Sized xs) = LL.elemIndex a xs
{-# INLINE elemIndex #-}

-- | Ordinal version of &#39;elemIndex&#39;
--   It statically checks boundary invariants.
--   If you don&#39;t internal structure on @&#39;Sized&#39;@,
--   then @&#39;sUnsafeElemIndex&#39;@ is much faster and
--   also safe for most cases.
--
--   Since 0.1.0.0
sElemIndex :: forall (n :: nat) f a.
              (SingI n, ListLike (f a) a, Eq a, HasOrdinal nat)
           =&gt; a -&gt; Sized f n a -&gt; Maybe (Ordinal n)
sElemIndex a (Sized xs) = do
  i &lt;- LL.elemIndex a xs
  case promote (P.fromIntegral i) of
    Monomorphic sn -&gt;
      case sn %:&lt; (sing :: Sing n) of
        STrue  -&gt; Just (OLt sn)
        SFalse -&gt; Nothing
{-# INLINE sElemIndex #-}

sUnsafeElemIndex :: forall (n :: nat) f a.
                    (SingI n, ListLike (f a) a, Eq a, HasOrdinal nat)
                 =&gt; a -&gt; Sized f n a -&gt; Maybe (Ordinal n)
sUnsafeElemIndex a (Sized xs) =
  unsafeFromInt . P.fromIntegral &lt;$&gt; LL.elemIndex a xs

-- | Returns all indices of the given element in the list.
--
-- Since 0.1.0.0
elemIndices :: (ListLike (f a) a, Eq a) =&gt; a -&gt; Sized f n a -&gt; [Int]
elemIndices a = LL.elemIndices a . runSized
{-# INLINE elemIndices #-}

-- | Ordinal version of &#39;elemIndices&#39;
--
-- Since 0.1.0.0
sElemIndices :: (HasOrdinal nat, SingI (n :: nat), ListLike (f a) a, Eq a)
             =&gt; a -&gt; Sized f n a -&gt; [Ordinal n]
sElemIndices p = P.fmap (unsafeFromInt . P.fromIntegral) . elemIndices p
{-# INLINE sElemIndices #-}

--------------------------------------------------------------------------------
-- Views and Patterns
--------------------------------------------------------------------------------

{-$ViewsAndPatterns #ViewsAndPatterns#

   With GHC&#39;s @ViewPatterns@ and @PatternSynonym@ extensions,
   we can pattern-match on arbitrary @Sized f n a@ if @f@ is list-like functor.
   Curretnly, there are two direction view and patterns: Cons and Snoc.
   Assuming underlying sequence type @f@ has O(1) implementation for &#39;LL.null&#39;, &#39;LL.head&#39;
   (resp. &#39;LL.last&#39;) and &#39;LL.tail&#39; (resp. &#39;LL.init&#39;), We can view and pattern-match on
   cons (resp. snoc) of @Sized f n a@ in O(1).
-}

{-$views #views#

   With @ViewPatterns@ extension, we can pattern-match on &#39;Sized&#39; value as follows:

@
slen :: (&#39;SingI&#39; n, &#39;ListLike (f a) a&#39; f) =&gt; &#39;Sized&#39; f n a -&gt; &#39;Sing&#39; n
slen (&#39;viewCons&#39; -&gt; &#39;NilCV&#39;)    = &#39;SZ&#39;
slen (&#39;viewCons&#39; -&gt; _ &#39;::-&#39; as) = &#39;SS&#39; (slen as)
slen _                          = error &quot;impossible&quot;
@

   The constraint @(&#39;SingI&#39; n, &#39;ListLike (f a) a&#39; f)@ is needed for view function.
   In the above, we have extra wildcard pattern (@_@) at the last.
   Code compiles if we removed it, but current GHC warns for incomplete pattern,
   although we know first two patterns exhausts all the case.

   Equivalently, we can use snoc-style pattern-matching:

@
slen :: (&#39;SingI&#39; n, &#39;ListLike (f a) a&#39; f) =&gt; &#39;Sized&#39; f n a -&gt; &#39;Sing&#39; n
slen (&#39;viewSnoc&#39; -&gt; &#39;NilSV&#39;)     = &#39;SZ&#39;
slen (&#39;viewSnoc&#39; -&gt; as &#39;:-::&#39; _) = &#39;SS&#39; (slen as)
@
-}

-- | View of the left end of sequence (cons-side).
--
-- Since 0.1.0.0
data ConsView f n a where
  NilCV :: ConsView f (Zero nat) a
  (::-) :: SingI n =&gt; a -&gt; Sized f n a -&gt; ConsView f (Succ n) a

infixr 5 ::-

-- | Case analysis for the cons-side of sequence.
--
-- Since 0.1.0.0
viewCons :: forall f a (n :: nat). (HasOrdinal nat, ListLike (f a) a)
         =&gt; Sized f n a
         -&gt; ConsView f n a
viewCons sz = case zeroOrSucc (sLength sz) of
  IsZero   -&gt; NilCV
  IsSucc n&#39; -&gt; withSingI n&#39; $ P.uncurry (::-) (uncons&#39; n&#39; sz)

-- | View of the left end of sequence (snoc-side).
--
-- Since 0.1.0.0
data SnocView f n a where
  NilSV :: SnocView f (Zero nat) a
  (:-::) :: SingI n =&gt; Sized f n a -&gt; a -&gt; SnocView f (Succ n) a
infixl 5 :-::

-- | Case analysis for the snoc-side of sequence.
--
-- Since 0.1.0.0
viewSnoc :: forall f (n :: nat) a. (HasOrdinal nat, ListLike (f a) a)
         =&gt; Sized f n a
         -&gt; SnocView f n a
viewSnoc sz = case zeroOrSucc (sLength sz) of
  IsZero   -&gt; NilSV
  IsSucc n&#39; -&gt;
    withSingI n&#39; $ P.uncurry (:-::) (unsnoc&#39; n&#39; sz)

{-$patterns #patterns#

   So we can pattern match on both end of sequence via views, but
   it is rather clumsy to nest it. For example:

@
nextToHead :: (&#39;ListLike (f a) a&#39; f, &#39;SingI&#39; n) =&gt; &#39;Sized&#39; f (&#39;S&#39; (&#39;S&#39; n)) a -&gt; a
nextToHead (&#39;viewCons&#39; -&gt; _ &#39;::-&#39; (&#39;viewCons&#39; -&gt; a &#39;::-&#39; _)) = a
@

   In such a case, with @PatternSynonyms@ extension we can write as follows:

@
nextToHead :: (&#39;ListLike (f a) a&#39; f, &#39;SingI&#39; n) =&gt; &#39;Sized&#39; f (&#39;S&#39; (&#39;S&#39; n)) a -&gt; a
nextToHead (_ &#39;:&lt;&#39; a &#39;:&lt;&#39; _) = a
@

   Of course, we can also rewrite above @slen@ example using @PatternSynonyms@:

@
slen :: (&#39;SingI&#39; n, &#39;ListLike (f a) a&#39; f) =&gt; &#39;Sized&#39; f n a -&gt; &#39;Sing&#39; n
slen &#39;NilL&#39;      = &#39;SZ&#39;
slen (_ &#39;:&lt;&#39; as) = &#39;SS&#39; (slen as)
slen _           = error &quot;impossible&quot;
@

   So, we can use @&#39;:&lt;&#39;@ and @&#39;NilL&#39;@ (resp. @&#39;:&gt;&#39;@ and @&#39;NilR&#39;@) to
   pattern-match directly on cons-side (resp. snoc-side) as we usually do for lists.
   @&#39;:&lt;&#39;@, @&#39;NilL&#39;@, @&#39;:&gt;&#39;@ and @&#39;NilR&#39;@ are neither functions nor data constructors,
   but pattern synonyms so we cannot use them in expression contexts.
   For more detail on pattern synonyms, see
   &lt;http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-synonyms GHC Users Guide&gt;
   and
   &lt;https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms HaskellWiki&gt;.
-}

infixr 5 :&lt;
-- | Pattern synonym for cons-side uncons.
pattern (:&lt;) :: forall nat f (n :: nat) a.
                (ListLike (f a) a, HasOrdinal nat)
             =&gt; forall (n1 :: nat).
                (n ~ Succ n1, SingI n1)
             =&gt; a -&gt; Sized f n1 a -&gt; Sized f n a
pattern a :&lt; as &lt;- (viewCons -&gt; a ::- as) where
   a :&lt; as = a &lt;| as

pattern NilL :: forall nat f (n :: nat) a.
                (ListLike (f a) a,  HasOrdinal nat)
             =&gt; (n ~ Zero nat) =&gt; Sized f n a
pattern NilL   &lt;- (viewCons -&gt; NilCV) where
  NilL = empty

infixl 5 :&gt;

pattern (:&gt;) :: forall nat f (n :: nat) a.
                (ListLike (f a) a, HasOrdinal nat)
             =&gt; forall (n1 :: nat).
                (n ~ Succ n1, SingI n1)
             =&gt; Sized f n1 a -&gt; a -&gt; Sized f n a
pattern a :&gt; b &lt;- (viewSnoc -&gt; a :-:: b) where
  a :&gt; b = a |&gt; b

pattern NilR :: forall nat f (n :: nat) a.
                (ListLike (f a) a,  HasOrdinal nat)
             =&gt; n ~ Zero nat =&gt; Sized f n a
pattern NilR   &lt;- (viewSnoc -&gt; NilSV) where
  NilR = empty

-- | Applicative instance, generalizing @&#39;Data.Monoid.ZipList&#39;@.
instance (Functor f, HasOrdinal nat, SingI n, ListLikeF f)
      =&gt; P.Applicative (Sized f (n :: nat)) where
  {-# SPECIALISE instance TL.KnownNat n =&gt; P.Applicative (Sized [] (n :: TL.Nat)) #-}
  {-# SPECIALISE instance TL.KnownNat n =&gt; P.Applicative (Sized Seq.Seq (n :: TL.Nat)) #-}
  {-# SPECIALISE instance TL.KnownNat n =&gt; P.Applicative (Sized V.Vector (n :: TL.Nat)) #-}

  pure (x :: a) =
    withListLikeF (Nothing :: Maybe (f a)) $
    replicate&#39; x
  {-# INLINE pure #-}

  (fs :: Sized f n (a -&gt; b)) &lt;*&gt; (xs :: Sized f n a) =
    withListLikeF (Nothing :: Maybe (f (a -&gt; b))) $
    withListLikeF (Nothing :: Maybe (f a)) $
    withListLikeF (Nothing :: Maybe (f b)) $
    zipWithSame ($) fs xs
  {-# INLINE [1] (&lt;*&gt;) #-}
{-# RULES
&quot;&lt;*&gt;/List&quot; [~1] forall fs xs.
  Sized fs &lt;*&gt; Sized xs = Sized (getZipList (ZipList fs &lt;*&gt; ZipList xs))
&quot;&lt;*&gt;/Seq&quot; [~1] forall fs xs.
  Sized fs &lt;*&gt; Sized xs = Sized (Seq.zipWith ($) fs xs)
&quot;&lt;*&gt;/Vector&quot; [~1] forall fs xs.
  Sized fs &lt;*&gt; Sized xs = Sized (V.zipWith ($) fs xs)
 #-}
</span> </pre></body></html></DOCTYPE>